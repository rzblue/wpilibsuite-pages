<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.0.0-alpha-1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classbasic__json.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classbasic__json-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>namespace for Niels Lohmann  
 <a href="classbasic__json.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="json_8h_source.html">/home/runner/work/allwpilib/allwpilib/wpiutil/src/main/native/thirdparty/json/include/wpi/json.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8224cb1d9448be74cc62b8c139547ef1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8224cb1d9448be74cc62b8c139547ef1">serializer</a> = ::wpi::detail::serializer&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="separator:a8224cb1d9448be74cc62b8c139547ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7fcb38964d53d35e84a80b8b1e8d11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aea7fcb38964d53d35e84a80b8b1e8d11">value_t</a> = <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a></td></tr>
<tr class="separator:aea7fcb38964d53d35e84a80b8b1e8d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5def9176cd6361a5b210a6c1a9396c28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> = ::wpi::json_pointer&lt; StringType &gt;</td></tr>
<tr class="memdesc:a5def9176cd6361a5b210a6c1a9396c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON Pointer, see wpi::json_pointer.  <a href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">More...</a><br /></td></tr>
<tr class="separator:a5def9176cd6361a5b210a6c1a9396c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8738738b9e5c4cdc6519e3799de38a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename SFINAE &gt; </td></tr>
<tr class="memitem:a5e8738738b9e5c4cdc6519e3799de38a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5e8738738b9e5c4cdc6519e3799de38a">json_serializer</a> = JSONSerializer&lt; T, SFINAE &gt;</td></tr>
<tr class="separator:a5e8738738b9e5c4cdc6519e3799de38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc0836764d6ba2580ee0c775ceeeab7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abbc0836764d6ba2580ee0c775ceeeab7">error_handler_t</a> = <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">detail::error_handler_t</a></td></tr>
<tr class="memdesc:abbc0836764d6ba2580ee0c775ceeeab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat decoding errors  <a href="classbasic__json.html#abbc0836764d6ba2580ee0c775ceeeab7">More...</a><br /></td></tr>
<tr class="separator:abbc0836764d6ba2580ee0c775ceeeab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2373759df24fffb094fd7789c726abe1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2373759df24fffb094fd7789c726abe1">cbor_tag_handler_t</a> = <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">detail::cbor_tag_handler_t</a></td></tr>
<tr class="memdesc:a2373759df24fffb094fd7789c726abe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat CBOR tags  <a href="classbasic__json.html#a2373759df24fffb094fd7789c726abe1">More...</a><br /></td></tr>
<tr class="separator:a2373759df24fffb094fd7789c726abe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2063ed828cd027216c549ac48527a562"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> = std::initializer_list&lt; <a class="el" href="classdetail_1_1json__ref.html">detail::json_ref</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;</td></tr>
<tr class="memdesc:a2063ed828cd027216c549ac48527a562"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper type for initializer lists of <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> values  <a href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">More...</a><br /></td></tr>
<tr class="separator:a2063ed828cd027216c549ac48527a562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcf8e1a03522bf1ea9bb6fb49251dab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0bcf8e1a03522bf1ea9bb6fb49251dab">input_format_t</a> = <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">detail::input_format_t</a></td></tr>
<tr class="separator:a0bcf8e1a03522bf1ea9bb6fb49251dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c291e7719ceccef199189e5ee4ecd4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0c291e7719ceccef199189e5ee4ecd4f">json_sax_t</a> = <a class="el" href="structjson__sax.html">json_sax</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a0c291e7719ceccef199189e5ee4ecd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SAX interface type, see wpi::json_sax.  <a href="classbasic__json.html#a0c291e7719ceccef199189e5ee4ecd4f">More...</a><br /></td></tr>
<tr class="separator:a0c291e7719ceccef199189e5ee4ecd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe811a234bbc90f4a0d3c6488272186"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#adfe811a234bbc90f4a0d3c6488272186">parse_event_t</a> = <a class="el" href="namespacedetail.html#a47b1bb0bbd3596589ed9187059c312ef">detail::parse_event_t</a></td></tr>
<tr class="memdesc:adfe811a234bbc90f4a0d3c6488272186"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser event types  <a href="classbasic__json.html#adfe811a234bbc90f4a0d3c6488272186">More...</a><br /></td></tr>
<tr class="separator:adfe811a234bbc90f4a0d3c6488272186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c201819ed5c9d9f58b59eb64fb454"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a144c201819ed5c9d9f58b59eb64fb454">parser_callback_t</a> = <a class="el" href="namespacedetail.html#a20a6b9b232b9f47ce057fe5cc5bbf511">detail::parser_callback_t</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a144c201819ed5c9d9f58b59eb64fb454"><td class="mdescLeft">&#160;</td><td class="mdescRight">per-element parser callback type  <a href="classbasic__json.html#a144c201819ed5c9d9f58b59eb64fb454">More...</a><br /></td></tr>
<tr class="separator:a144c201819ed5c9d9f58b59eb64fb454"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7528ae3cfe082b3e6280eb5dfab4700b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hedley_8h.html#a5f2aaec3b681d0a72f7d6e90b70cdcd1">JSON_HEDLEY_RETURNS_NON_NULL</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a> () const noexcept</td></tr>
<tr class="memdesc:a7528ae3cfe082b3e6280eb5dfab4700b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type as string  <a href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">More...</a><br /></td></tr>
<tr class="separator:a7528ae3cfe082b3e6280eb5dfab4700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1aaddd9686fb1dd50203c2138858df7e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1aaddd9686fb1dd50203c2138858df7e">get_allocator</a> ()</td></tr>
<tr class="memdesc:a1aaddd9686fb1dd50203c2138858df7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the allocator associated with the container  <a href="classbasic__json.html#a1aaddd9686fb1dd50203c2138858df7e">More...</a><br /></td></tr>
<tr class="separator:a1aaddd9686fb1dd50203c2138858df7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08303da85f75965764bb0c8d8b79a449"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a08303da85f75965764bb0c8d8b79a449">meta</a> ()</td></tr>
<tr class="memdesc:a08303da85f75965764bb0c8d8b79a449"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns version information on the library  <a href="classbasic__json.html#a08303da85f75965764bb0c8d8b79a449">More...</a><br /></td></tr>
<tr class="separator:a08303da85f75965764bb0c8d8b79a449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eae76ffa6335685fa38190a18806d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macro__scope_8h.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> bool static SAX bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2eae76ffa6335685fa38190a18806d55">sax_parse</a> (InputType &amp;&amp;i, SAX *sax, <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a> <a class="el" href="format_8h.html#ab5e334342978e8c898e32e5b4f7d08fa">format</a>=<a class="el" href="json__fwd_8h.html#ae6eede511f01c9f33342044d36a388fa">input_format_t::json</a>, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="separator:a2eae76ffa6335685fa38190a18806d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2094d16fe8fd49c20eca61fa88d602"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , class SAX &gt; </td></tr>
<tr class="memitem:a4e2094d16fe8fd49c20eca61fa88d602"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4e2094d16fe8fd49c20eca61fa88d602">sax_parse</a> (IteratorType first, IteratorType last, SAX *sax, <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a> <a class="el" href="format_8h.html#ab5e334342978e8c898e32e5b4f7d08fa">format</a>=<a class="el" href="json__fwd_8h.html#ae6eede511f01c9f33342044d36a388fa">input_format_t::json</a>, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a4e2094d16fe8fd49c20eca61fa88d602"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate SAX events  <a href="classbasic__json.html#a4e2094d16fe8fd49c20eca61fa88d602">More...</a><br /></td></tr>
<tr class="separator:a4e2094d16fe8fd49c20eca61fa88d602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696ab4a7073c479bb1ef24c23c3d3d67"><td class="memTemplParams" colspan="2">template&lt;typename SAX &gt; </td></tr>
<tr class="memitem:a696ab4a7073c479bb1ef24c23c3d3d67"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a696ab4a7073c479bb1ef24c23c3d3d67">sax_parse</a> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, SAX *sax, <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a> <a class="el" href="format_8h.html#ab5e334342978e8c898e32e5b4f7d08fa">format</a>=<a class="el" href="json__fwd_8h.html#ae6eede511f01c9f33342044d36a388fa">input_format_t::json</a>, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a696ab4a7073c479bb1ef24c23c3d3d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate SAX events  <a href="classbasic__json.html#a696ab4a7073c479bb1ef24c23c3d3d67">More...</a><br /></td></tr>
<tr class="separator:a696ab4a7073c479bb1ef24c23c3d3d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7e8bca0d3d745150dbaae538443bb626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macro__scope_8h.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7e8bca0d3d745150dbaae538443bb626">__pad3__</a>: <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> m_type = <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a></td></tr>
<tr class="separator:a7e8bca0d3d745150dbaae538443bb626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bc6074bd3f9ac2bdab12ebc02d70f5"><td class="memItemLeft" align="right" valign="top">json_value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = {}</td></tr>
<tr class="memdesc:a34bc6074bd3f9ac2bdab12ebc02d70f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">the value of the current element  <a href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">More...</a><br /></td></tr>
<tr class="separator:a34bc6074bd3f9ac2bdab12ebc02d70f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a> &gt; </td></tr>
<tr class="memitem:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6275ed57bae6866cdf5db5370a7ad47c">detail::external_constructor</a></td></tr>
<tr class="separator:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c40387c5ebc1df2bbfdd83f01fc9e1"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:a51c40387c5ebc1df2bbfdd83f01fc9e1"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a51c40387c5ebc1df2bbfdd83f01fc9e1">::wpi::json_pointer</a></td></tr>
<tr class="separator:a51c40387c5ebc1df2bbfdd83f01fc9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6d99ed21debf20602cc7eb9f2ef01a"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename InputType &gt; </td></tr>
<tr class="memitem:aaa6d99ed21debf20602cc7eb9f2ef01a"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aaa6d99ed21debf20602cc7eb9f2ef01a">::wpi::detail::parser</a></td></tr>
<tr class="separator:aaa6d99ed21debf20602cc7eb9f2ef01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d20ee95fa3b90049a0b658740940df"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a95d20ee95fa3b90049a0b658740940df"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a95d20ee95fa3b90049a0b658740940df">::wpi::detail::iter_impl</a></td></tr>
<tr class="separator:a95d20ee95fa3b90049a0b658740940df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae825bd970ff2124e96e2715b44d74b0d"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename CharType &gt; </td></tr>
<tr class="memitem:ae825bd970ff2124e96e2715b44d74b0d"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae825bd970ff2124e96e2715b44d74b0d">::wpi::detail::binary_writer</a></td></tr>
<tr class="separator:ae825bd970ff2124e96e2715b44d74b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1076517313bebd9317abb5f8ae1674d3"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename InputType , typename SAX &gt; </td></tr>
<tr class="memitem:a1076517313bebd9317abb5f8ae1674d3"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1076517313bebd9317abb5f8ae1674d3">::wpi::detail::binary_reader</a></td></tr>
<tr class="separator:a1076517313bebd9317abb5f8ae1674d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925bb3befb53793ac51d4cfddb4c6a86"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a925bb3befb53793ac51d4cfddb4c6a86"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a925bb3befb53793ac51d4cfddb4c6a86">::wpi::detail::json_sax_dom_parser</a></td></tr>
<tr class="separator:a925bb3befb53793ac51d4cfddb4c6a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01207613d33f5fe85434326323472e69"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a01207613d33f5fe85434326323472e69"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a01207613d33f5fe85434326323472e69">::wpi::detail::json_sax_dom_callback_parser</a></td></tr>
<tr class="separator:a01207613d33f5fe85434326323472e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f1e737927201b292c4d4e1935614ce"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a93f1e737927201b292c4d4e1935614ce">::wpi::detail::exception</a></td></tr>
<tr class="separator:a93f1e737927201b292c4d4e1935614ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9907af448f7ff794120033e132025f6"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af9907af448f7ff794120033e132025f6">operator&lt;&lt;</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;j, std::istream &amp;i)</td></tr>
<tr class="memdesc:af9907af448f7ff794120033e132025f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classbasic__json.html#af9907af448f7ff794120033e132025f6">More...</a><br /></td></tr>
<tr class="separator:af9907af448f7ff794120033e132025f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0de29387d532e0bc5f2475cb83995d"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aea0de29387d532e0bc5f2475cb83995d">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:aea0de29387d532e0bc5f2475cb83995d"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classbasic__json.html#aea0de29387d532e0bc5f2475cb83995d">More...</a><br /></td></tr>
<tr class="separator:aea0de29387d532e0bc5f2475cb83995d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">element access</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >Access to the JSON value. </p>
</td></tr>
<tr class="memitem:a603779687f401ad11de45f8397f92296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a603779687f401ad11de45f8397f92296">at</a> (<a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> idx)</td></tr>
<tr class="memdesc:a603779687f401ad11de45f8397f92296"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element with bounds checking  <a href="classbasic__json.html#a603779687f401ad11de45f8397f92296">More...</a><br /></td></tr>
<tr class="separator:a603779687f401ad11de45f8397f92296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e6b7245d17021327eb3962d73ccc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a98e6b7245d17021327eb3962d73ccc54">at</a> (<a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> idx) const</td></tr>
<tr class="memdesc:a98e6b7245d17021327eb3962d73ccc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element with bounds checking  <a href="classbasic__json.html#a98e6b7245d17021327eb3962d73ccc54">More...</a><br /></td></tr>
<tr class="separator:a98e6b7245d17021327eb3962d73ccc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf1894e1b70a4caebd95adec60e845a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aedf1894e1b70a4caebd95adec60e845a">at</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:aedf1894e1b70a4caebd95adec60e845a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="classbasic__json.html#aedf1894e1b70a4caebd95adec60e845a">More...</a><br /></td></tr>
<tr class="separator:aedf1894e1b70a4caebd95adec60e845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc69e86b65aa8b571ccad9d581ca5a2b"><td class="memTemplParams" colspan="2">template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afc69e86b65aa8b571ccad9d581ca5a2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afc69e86b65aa8b571ccad9d581ca5a2b">at</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:afc69e86b65aa8b571ccad9d581ca5a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="classbasic__json.html#afc69e86b65aa8b571ccad9d581ca5a2b">More...</a><br /></td></tr>
<tr class="separator:afc69e86b65aa8b571ccad9d581ca5a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc32b953a4e343dc7f8ab3465743f399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afc32b953a4e343dc7f8ab3465743f399">at</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:afc32b953a4e343dc7f8ab3465743f399"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="classbasic__json.html#afc32b953a4e343dc7f8ab3465743f399">More...</a><br /></td></tr>
<tr class="separator:afc32b953a4e343dc7f8ab3465743f399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee87279fb115f6d57967e6e8f5542faa"><td class="memTemplParams" colspan="2">template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aee87279fb115f6d57967e6e8f5542faa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aee87279fb115f6d57967e6e8f5542faa">at</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:aee87279fb115f6d57967e6e8f5542faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="classbasic__json.html#aee87279fb115f6d57967e6e8f5542faa">More...</a><br /></td></tr>
<tr class="separator:aee87279fb115f6d57967e6e8f5542faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dfeae16fa9a8ec1390a27d6a4a58b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa3dfeae16fa9a8ec1390a27d6a4a58b3">operator[]</a> (<a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> idx)</td></tr>
<tr class="memdesc:aa3dfeae16fa9a8ec1390a27d6a4a58b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element  <a href="classbasic__json.html#aa3dfeae16fa9a8ec1390a27d6a4a58b3">More...</a><br /></td></tr>
<tr class="separator:aa3dfeae16fa9a8ec1390a27d6a4a58b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61677841384622af7c3174f3f10df621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a61677841384622af7c3174f3f10df621">operator[]</a> (<a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> idx) const</td></tr>
<tr class="memdesc:a61677841384622af7c3174f3f10df621"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element  <a href="classbasic__json.html#a61677841384622af7c3174f3f10df621">More...</a><br /></td></tr>
<tr class="separator:a61677841384622af7c3174f3f10df621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272177c4eb206c70f41e35146915b710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a272177c4eb206c70f41e35146915b710">operator[]</a> (typename object_t::key_type key)</td></tr>
<tr class="memdesc:a272177c4eb206c70f41e35146915b710"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="classbasic__json.html#a272177c4eb206c70f41e35146915b710">More...</a><br /></td></tr>
<tr class="separator:a272177c4eb206c70f41e35146915b710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57b78559cad28275bc515bb2a072605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af57b78559cad28275bc515bb2a072605">operator[]</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:af57b78559cad28275bc515bb2a072605"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="classbasic__json.html#af57b78559cad28275bc515bb2a072605">More...</a><br /></td></tr>
<tr class="separator:af57b78559cad28275bc515bb2a072605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb748eeb63f40f12f81f9e9c5d53d127"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb748eeb63f40f12f81f9e9c5d53d127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abb748eeb63f40f12f81f9e9c5d53d127">operator[]</a> (T *key)</td></tr>
<tr class="separator:abb748eeb63f40f12f81f9e9c5d53d127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e43d3f7092719836ac3e8249044bb6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19e43d3f7092719836ac3e8249044bb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a19e43d3f7092719836ac3e8249044bb6">operator[]</a> (T *key) const</td></tr>
<tr class="separator:a19e43d3f7092719836ac3e8249044bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7e1bd642902ec90f118f00d48c024d"><td class="memTemplParams" colspan="2">template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5a7e1bd642902ec90f118f00d48c024d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5a7e1bd642902ec90f118f00d48c024d">operator[]</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a5a7e1bd642902ec90f118f00d48c024d"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="classbasic__json.html#a5a7e1bd642902ec90f118f00d48c024d">More...</a><br /></td></tr>
<tr class="separator:a5a7e1bd642902ec90f118f00d48c024d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb04aaee2ee66a6c822aaad827123314"><td class="memTemplParams" colspan="2">template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afb04aaee2ee66a6c822aaad827123314"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afb04aaee2ee66a6c822aaad827123314">operator[]</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:afb04aaee2ee66a6c822aaad827123314"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="classbasic__json.html#afb04aaee2ee66a6c822aaad827123314">More...</a><br /></td></tr>
<tr class="separator:afb04aaee2ee66a6c822aaad827123314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb507ac4a659d45a9ccdfb67a0646ec"><td class="memTemplParams" colspan="2">template&lt;class ValueType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; !<a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3fb507ac4a659d45a9ccdfb67a0646ec"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">value</a> (const typename object_t::key_type &amp;key, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a3fb507ac4a659d45a9ccdfb67a0646ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <a href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">More...</a><br /></td></tr>
<tr class="separator:a3fb507ac4a659d45a9ccdfb67a0646ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1460a0f28bedca9050f2259ec6bf86e6"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; !<a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1460a0f28bedca9050f2259ec6bf86e6"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1460a0f28bedca9050f2259ec6bf86e6">value</a> (const typename object_t::key_type &amp;key, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:a1460a0f28bedca9050f2259ec6bf86e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <a href="classbasic__json.html#a1460a0f28bedca9050f2259ec6bf86e6">More...</a><br /></td></tr>
<tr class="separator:a1460a0f28bedca9050f2259ec6bf86e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58469bce489ece80e50e7ed59fa09484"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;!<a class="el" href="namespacedetail.html#a06ad3beb30c2c13d70ae518317a3156f">detail::is_json_pointer</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__comparable.html">is_comparable_with_object_key</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a58469bce489ece80e50e7ed59fa09484"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a58469bce489ece80e50e7ed59fa09484">value</a> (KeyType &amp;&amp;key, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a58469bce489ece80e50e7ed59fa09484"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <a href="classbasic__json.html#a58469bce489ece80e50e7ed59fa09484">More...</a><br /></td></tr>
<tr class="separator:a58469bce489ece80e50e7ed59fa09484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d24993dea7dcd5442465e43b0554cb"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class KeyType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;!<a class="el" href="namespacedetail.html#a06ad3beb30c2c13d70ae518317a3156f">detail::is_json_pointer</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__comparable.html">is_comparable_with_object_key</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac7d24993dea7dcd5442465e43b0554cb"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac7d24993dea7dcd5442465e43b0554cb">value</a> (KeyType &amp;&amp;key, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:ac7d24993dea7dcd5442465e43b0554cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <a href="classbasic__json.html#ac7d24993dea7dcd5442465e43b0554cb">More...</a><br /></td></tr>
<tr class="separator:ac7d24993dea7dcd5442465e43b0554cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e07f0a0e66b05e7b77b95f623cbfac1"><td class="memTemplParams" colspan="2">template&lt;class ValueType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8e07f0a0e66b05e7b77b95f623cbfac1"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8e07f0a0e66b05e7b77b95f623cbfac1">value</a> (const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a8e07f0a0e66b05e7b77b95f623cbfac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <a href="classbasic__json.html#a8e07f0a0e66b05e7b77b95f623cbfac1">More...</a><br /></td></tr>
<tr class="separator:a8e07f0a0e66b05e7b77b95f623cbfac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af435aab4d160572776d7e66c3809e4b1"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af435aab4d160572776d7e66c3809e4b1"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af435aab4d160572776d7e66c3809e4b1">value</a> (const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:af435aab4d160572776d7e66c3809e4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <a href="classbasic__json.html#af435aab4d160572776d7e66c3809e4b1">More...</a><br /></td></tr>
<tr class="separator:af435aab4d160572776d7e66c3809e4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6626fcc2720b8cda13c3789a9613bef"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class BasicJsonType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac6626fcc2720b8cda13c3789a9613bef"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac6626fcc2720b8cda13c3789a9613bef">JSON_HEDLEY_DEPRECATED_FOR</a> (3.11.0, <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">basic_json::json_pointer</a> <a class="el" href="_third_party_notices_8txt.html#a3d2bcfd013d8297d0df0a31cb92e058c">or</a> wpi::json_pointer&lt; <a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">basic_json::string_t</a> &gt;) ValueType <a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">value</a>(const</td></tr>
<tr class="memdesc:ac6626fcc2720b8cda13c3789a9613bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the first element  <a href="classbasic__json.html#ac6626fcc2720b8cda13c3789a9613bef">More...</a><br /></td></tr>
<tr class="separator:ac6626fcc2720b8cda13c3789a9613bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85577855985468abef750d5265e23c2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a85577855985468abef750d5265e23c2a">front</a> () const</td></tr>
<tr class="memdesc:a85577855985468abef750d5265e23c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the first element  <a href="classbasic__json.html#a85577855985468abef750d5265e23c2a">More...</a><br /></td></tr>
<tr class="separator:a85577855985468abef750d5265e23c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafea743a0a74f86433b8b7cc5bb24bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#adafea743a0a74f86433b8b7cc5bb24bf">back</a> ()</td></tr>
<tr class="memdesc:adafea743a0a74f86433b8b7cc5bb24bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the last element  <a href="classbasic__json.html#adafea743a0a74f86433b8b7cc5bb24bf">More...</a><br /></td></tr>
<tr class="separator:adafea743a0a74f86433b8b7cc5bb24bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf48c36e00720e01f8f6bbd3df0bf5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1bf48c36e00720e01f8f6bbd3df0bf5b">back</a> () const</td></tr>
<tr class="memdesc:a1bf48c36e00720e01f8f6bbd3df0bf5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the last element  <a href="classbasic__json.html#a1bf48c36e00720e01f8f6bbd3df0bf5b">More...</a><br /></td></tr>
<tr class="separator:a1bf48c36e00720e01f8f6bbd3df0bf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5ed019983b582705ef5ee43d15ca24"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7a5ed019983b582705ef5ee43d15ca24"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7a5ed019983b582705ef5ee43d15ca24">erase</a> (IteratorType pos)</td></tr>
<tr class="memdesc:a7a5ed019983b582705ef5ee43d15ca24"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element given an iterator  <a href="classbasic__json.html#a7a5ed019983b582705ef5ee43d15ca24">More...</a><br /></td></tr>
<tr class="separator:a7a5ed019983b582705ef5ee43d15ca24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151124c5b91ecb1278c7e191053ce9ca"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a151124c5b91ecb1278c7e191053ce9ca"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a151124c5b91ecb1278c7e191053ce9ca">erase</a> (IteratorType first, IteratorType last)</td></tr>
<tr class="memdesc:a151124c5b91ecb1278c7e191053ce9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove elements given an iterator range  <a href="classbasic__json.html#a151124c5b91ecb1278c7e191053ce9ca">More...</a><br /></td></tr>
<tr class="separator:a151124c5b91ecb1278c7e191053ce9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d29d171d8941523a937bb6b5132b5a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8d29d171d8941523a937bb6b5132b5a7">erase</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:a8d29d171d8941523a937bb6b5132b5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON object given a key  <a href="classbasic__json.html#a8d29d171d8941523a937bb6b5132b5a7">More...</a><br /></td></tr>
<tr class="separator:a8d29d171d8941523a937bb6b5132b5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3054e673f67fa325fbdcd0bf73d03c7b"><td class="memTemplParams" colspan="2">template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3054e673f67fa325fbdcd0bf73d03c7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3054e673f67fa325fbdcd0bf73d03c7b">erase</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a3054e673f67fa325fbdcd0bf73d03c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON object given a key  <a href="classbasic__json.html#a3054e673f67fa325fbdcd0bf73d03c7b">More...</a><br /></td></tr>
<tr class="separator:a3054e673f67fa325fbdcd0bf73d03c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e480e9d2391485c79747bb756628f61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0e480e9d2391485c79747bb756628f61">erase</a> (const <a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> idx)</td></tr>
<tr class="memdesc:a0e480e9d2391485c79747bb756628f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON array given an index  <a href="classbasic__json.html#a0e480e9d2391485c79747bb756628f61">More...</a><br /></td></tr>
<tr class="separator:a0e480e9d2391485c79747bb756628f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">exceptions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >Classes to implement user-defined exceptions. </p>
</td></tr>
<tr class="memitem:ab671bd0e5eef59e58d362e6cd8937633"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab671bd0e5eef59e58d362e6cd8937633">exception</a> = <a class="el" href="classdetail_1_1exception.html">detail::exception</a></td></tr>
<tr class="separator:ab671bd0e5eef59e58d362e6cd8937633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0da064d46469bb762afcecd1c361f1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab0da064d46469bb762afcecd1c361f1a">parse_error</a> = <a class="el" href="classdetail_1_1parse__error.html">detail::parse_error</a></td></tr>
<tr class="separator:ab0da064d46469bb762afcecd1c361f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbe40f1942d8e38ab2effc7988b05ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9dbe40f1942d8e38ab2effc7988b05ea">invalid_iterator</a> = <a class="el" href="classdetail_1_1invalid__iterator.html">detail::invalid_iterator</a></td></tr>
<tr class="separator:a9dbe40f1942d8e38ab2effc7988b05ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db56e21a2c72186979c6f6f0469557"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a14db56e21a2c72186979c6f6f0469557">type_error</a> = <a class="el" href="classdetail_1_1type__error.html">detail::type_error</a></td></tr>
<tr class="separator:a14db56e21a2c72186979c6f6f0469557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144d3cb5914a0a12c2f5d2b982a2214a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a144d3cb5914a0a12c2f5d2b982a2214a">out_of_range</a> = <a class="el" href="classdetail_1_1out__of__range.html">detail::out_of_range</a></td></tr>
<tr class="separator:a144d3cb5914a0a12c2f5d2b982a2214a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2ef54e2baf390523dd6a5bc4ccccef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aab2ef54e2baf390523dd6a5bc4ccccef">other_error</a> = <a class="el" href="classdetail_1_1other__error.html">detail::other_error</a></td></tr>
<tr class="separator:aab2ef54e2baf390523dd6a5bc4ccccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">container types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >The canonic container types to use <a class="el" href="classbasic__json.html">basic_json</a> like any other STL container. </p>
</td></tr>
<tr class="memitem:ad9e6b75c7cc0db798b91e52edca5f4ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad9e6b75c7cc0db798b91e52edca5f4ca">value_type</a> = <a class="el" href="classbasic__json.html">basic_json</a></td></tr>
<tr class="memdesc:ad9e6b75c7cc0db798b91e52edca5f4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of elements in a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container  <a href="classbasic__json.html#ad9e6b75c7cc0db798b91e52edca5f4ca">More...</a><br /></td></tr>
<tr class="separator:ad9e6b75c7cc0db798b91e52edca5f4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95f366d506aca733799e4c310927b5d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> = <a class="el" href="classbasic__json.html#ad9e6b75c7cc0db798b91e52edca5f4ca">value_type</a> &amp;</td></tr>
<tr class="memdesc:aa95f366d506aca733799e4c310927b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element reference  <a href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">More...</a><br /></td></tr>
<tr class="separator:aa95f366d506aca733799e4c310927b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d32cf719260c22b33bab670cd5602b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> = const <a class="el" href="classbasic__json.html#ad9e6b75c7cc0db798b91e52edca5f4ca">value_type</a> &amp;</td></tr>
<tr class="memdesc:ac9d32cf719260c22b33bab670cd5602b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element const reference  <a href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">More...</a><br /></td></tr>
<tr class="separator:ac9d32cf719260c22b33bab670cd5602b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe32d636c1b78861884dde9716b22b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2fe32d636c1b78861884dde9716b22b6">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a2fe32d636c1b78861884dde9716b22b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type to represent differences between iterators  <a href="classbasic__json.html#a2fe32d636c1b78861884dde9716b22b6">More...</a><br /></td></tr>
<tr class="separator:a2fe32d636c1b78861884dde9716b22b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883ac4726a370dbf98474944ec0a0acc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a883ac4726a370dbf98474944ec0a0acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type to represent container sizes  <a href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">More...</a><br /></td></tr>
<tr class="separator:a883ac4726a370dbf98474944ec0a0acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485873eed243b6ca7e30c96130a5ec2d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a> = AllocatorType&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a485873eed243b6ca7e30c96130a5ec2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the allocator type  <a href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">More...</a><br /></td></tr>
<tr class="separator:a485873eed243b6ca7e30c96130a5ec2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02a5d1bf4e9cd1bdec90e97f4ea6f95"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac02a5d1bf4e9cd1bdec90e97f4ea6f95">pointer</a> = typename std::allocator_traits&lt; <a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a> &gt;::pointer</td></tr>
<tr class="memdesc:ac02a5d1bf4e9cd1bdec90e97f4ea6f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element pointer  <a href="classbasic__json.html#ac02a5d1bf4e9cd1bdec90e97f4ea6f95">More...</a><br /></td></tr>
<tr class="separator:ac02a5d1bf4e9cd1bdec90e97f4ea6f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ac2566e6ab084c5c1e044d132aa4a3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a28ac2566e6ab084c5c1e044d132aa4a3">const_pointer</a> = typename std::allocator_traits&lt; <a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a> &gt;::const_pointer</td></tr>
<tr class="memdesc:a28ac2566e6ab084c5c1e044d132aa4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element const pointer  <a href="classbasic__json.html#a28ac2566e6ab084c5c1e044d132aa4a3">More...</a><br /></td></tr>
<tr class="separator:a28ac2566e6ab084c5c1e044d132aa4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2935c91b82c8e586b1dd68ad665075a6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> = iter_impl&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a2935c91b82c8e586b1dd68ad665075a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">an iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container  <a href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">More...</a><br /></td></tr>
<tr class="separator:a2935c91b82c8e586b1dd68ad665075a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3470194c24d964e40d9be0b177cbc3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> = iter_impl&lt; const <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a8f3470194c24d964e40d9be0b177cbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">a const iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container  <a href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">More...</a><br /></td></tr>
<tr class="separator:a8f3470194c24d964e40d9be0b177cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac639cd1b4238d158286e7e21b5829709"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac639cd1b4238d158286e7e21b5829709">reverse_iterator</a> = json_reverse_iterator&lt; typename <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">basic_json::iterator</a> &gt;</td></tr>
<tr class="memdesc:ac639cd1b4238d158286e7e21b5829709"><td class="mdescLeft">&#160;</td><td class="mdescRight">a reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container  <a href="classbasic__json.html#ac639cd1b4238d158286e7e21b5829709">More...</a><br /></td></tr>
<tr class="separator:ac639cd1b4238d158286e7e21b5829709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa7d4c7719ab82aa8c77a83642c843f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a> = json_reverse_iterator&lt; typename <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">basic_json::const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a2aa7d4c7719ab82aa8c77a83642c843f"><td class="mdescLeft">&#160;</td><td class="mdescRight">a const reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container  <a href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">More...</a><br /></td></tr>
<tr class="separator:a2aa7d4c7719ab82aa8c77a83642c843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON value data types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >The data types to store a JSON value.</p>
<p >These types are derived from the template arguments passed to class <a class="el" href="classbasic__json.html">basic_json</a>. </p>
</td></tr>
<tr class="memitem:af2fea7b2039e4308b8e8c22a0dd5b570"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af2fea7b2039e4308b8e8c22a0dd5b570">default_object_comparator_t</a> = std::less&lt; StringType &gt;</td></tr>
<tr class="memdesc:af2fea7b2039e4308b8e8c22a0dd5b570"><td class="mdescLeft">&#160;</td><td class="mdescRight">default object key comparator type The actual object key comparator type (<a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a>) may be different.  <a href="classbasic__json.html#af2fea7b2039e4308b8e8c22a0dd5b570">More...</a><br /></td></tr>
<tr class="separator:af2fea7b2039e4308b8e8c22a0dd5b570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770279b71f788fe3f76411eedf5b1956"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a770279b71f788fe3f76411eedf5b1956">object_t</a> = ObjectType&lt; StringType, <a class="el" href="classbasic__json.html">basic_json</a>, <a class="el" href="classbasic__json.html#af2fea7b2039e4308b8e8c22a0dd5b570">default_object_comparator_t</a>, AllocatorType&lt; std::pair&lt; const StringType, <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a770279b71f788fe3f76411eedf5b1956"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for an object  <a href="classbasic__json.html#a770279b71f788fe3f76411eedf5b1956">More...</a><br /></td></tr>
<tr class="separator:a770279b71f788fe3f76411eedf5b1956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf28eb944e7c06aa47f0bc3a9d6f454"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7cf28eb944e7c06aa47f0bc3a9d6f454">array_t</a> = ArrayType&lt; <a class="el" href="classbasic__json.html">basic_json</a>, AllocatorType&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;</td></tr>
<tr class="memdesc:a7cf28eb944e7c06aa47f0bc3a9d6f454"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for an array  <a href="classbasic__json.html#a7cf28eb944e7c06aa47f0bc3a9d6f454">More...</a><br /></td></tr>
<tr class="separator:a7cf28eb944e7c06aa47f0bc3a9d6f454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807932caebf0d62abc8642b9d1a2e5ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a> = StringType</td></tr>
<tr class="memdesc:a807932caebf0d62abc8642b9d1a2e5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a string  <a href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">More...</a><br /></td></tr>
<tr class="separator:a807932caebf0d62abc8642b9d1a2e5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af396ac808d774d4ea0db4c7da11ce569"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af396ac808d774d4ea0db4c7da11ce569">boolean_t</a> = BooleanType</td></tr>
<tr class="memdesc:af396ac808d774d4ea0db4c7da11ce569"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a boolean  <a href="classbasic__json.html#af396ac808d774d4ea0db4c7da11ce569">More...</a><br /></td></tr>
<tr class="separator:af396ac808d774d4ea0db4c7da11ce569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b702448867b892700c768db4208a670"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8b702448867b892700c768db4208a670">number_integer_t</a> = NumberIntegerType</td></tr>
<tr class="memdesc:a8b702448867b892700c768db4208a670"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (integer)  <a href="classbasic__json.html#a8b702448867b892700c768db4208a670">More...</a><br /></td></tr>
<tr class="separator:a8b702448867b892700c768db4208a670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb9c6a13e947a86e2a13fbe6ebd77f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aebb9c6a13e947a86e2a13fbe6ebd77f4">number_unsigned_t</a> = NumberUnsignedType</td></tr>
<tr class="memdesc:aebb9c6a13e947a86e2a13fbe6ebd77f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (unsigned)  <a href="classbasic__json.html#aebb9c6a13e947a86e2a13fbe6ebd77f4">More...</a><br /></td></tr>
<tr class="separator:aebb9c6a13e947a86e2a13fbe6ebd77f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd24dfabbdd1dc35513c82244633ca4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1fd24dfabbdd1dc35513c82244633ca4">number_float_t</a> = NumberFloatType</td></tr>
<tr class="memdesc:a1fd24dfabbdd1dc35513c82244633ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (floating-point)  <a href="classbasic__json.html#a1fd24dfabbdd1dc35513c82244633ca4">More...</a><br /></td></tr>
<tr class="separator:a1fd24dfabbdd1dc35513c82244633ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e4e8a0166fd47c006b82b20b2dcd7f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a10e4e8a0166fd47c006b82b20b2dcd7f">binary_t</a> = wpi::byte_container_with_subtype&lt; BinaryType &gt;</td></tr>
<tr class="memdesc:a10e4e8a0166fd47c006b82b20b2dcd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a packed binary type  <a href="classbasic__json.html#a10e4e8a0166fd47c006b82b20b2dcd7f">More...</a><br /></td></tr>
<tr class="separator:a10e4e8a0166fd47c006b82b20b2dcd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7866de66dd6c55590efa7cf0ef79e74f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> = <a class="el" href="namespacedetail.html#acf3e5af512080ec5b71496dde9e0651c">detail::actual_object_comparator_t</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a7866de66dd6c55590efa7cf0ef79e74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">object key comparator type  <a href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">More...</a><br /></td></tr>
<tr class="separator:a7866de66dd6c55590efa7cf0ef79e74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">modifiers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >checks whether the container is empty.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/empty/">https://json.nlohmann.me/api/basic_json/empty/</a></dd></dl>
<p>returns the number of elements </p><dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/size/">https://json.nlohmann.me/api/basic_json/size/</a></dd></dl>
<p>returns the maximum possible number of elements </p><dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/max_size/">https://json.nlohmann.me/api/basic_json/max_size/</a> </dd></dl>
</td></tr>
<tr class="memitem:aee0ae36cbfb0336832ebc0374c3c7679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">swap</a> (<a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> left, <a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> right) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>)</td></tr>
<tr class="memdesc:aee0ae36cbfb0336832ebc0374c3c7679"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">More...</a><br /></td></tr>
<tr class="separator:aee0ae36cbfb0336832ebc0374c3c7679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042aa42f535d1dbf2176d159fd3d96eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a042aa42f535d1dbf2176d159fd3d96eb">operator+=</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a042aa42f535d1dbf2176d159fd3d96eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classbasic__json.html#a042aa42f535d1dbf2176d159fd3d96eb">More...</a><br /></td></tr>
<tr class="separator:a042aa42f535d1dbf2176d159fd3d96eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102e459f1d163cea963ed6fdda595cd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a102e459f1d163cea963ed6fdda595cd3">push_back</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a102e459f1d163cea963ed6fdda595cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classbasic__json.html#a102e459f1d163cea963ed6fdda595cd3">More...</a><br /></td></tr>
<tr class="separator:a102e459f1d163cea963ed6fdda595cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf3e602301f1b9fc81c445c8f3bd1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afbbf3e602301f1b9fc81c445c8f3bd1a">operator+=</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:afbbf3e602301f1b9fc81c445c8f3bd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classbasic__json.html#afbbf3e602301f1b9fc81c445c8f3bd1a">More...</a><br /></td></tr>
<tr class="separator:afbbf3e602301f1b9fc81c445c8f3bd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efb88d640b634b77af5825321e6c4ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4efb88d640b634b77af5825321e6c4ba">push_back</a> (const typename object_t::value_type &amp;val)</td></tr>
<tr class="memdesc:a4efb88d640b634b77af5825321e6c4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="classbasic__json.html#a4efb88d640b634b77af5825321e6c4ba">More...</a><br /></td></tr>
<tr class="separator:a4efb88d640b634b77af5825321e6c4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024a7d334069a60f8cb95c3f858fc9e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a024a7d334069a60f8cb95c3f858fc9e6">operator+=</a> (const typename object_t::value_type &amp;val)</td></tr>
<tr class="memdesc:a024a7d334069a60f8cb95c3f858fc9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="classbasic__json.html#a024a7d334069a60f8cb95c3f858fc9e6">More...</a><br /></td></tr>
<tr class="separator:a024a7d334069a60f8cb95c3f858fc9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabd8c4eea861419dc2629610a922e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#adabd8c4eea861419dc2629610a922e97">push_back</a> (<a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> init)</td></tr>
<tr class="memdesc:adabd8c4eea861419dc2629610a922e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="classbasic__json.html#adabd8c4eea861419dc2629610a922e97">More...</a><br /></td></tr>
<tr class="separator:adabd8c4eea861419dc2629610a922e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3350669b0628bf54a4771512a55f135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae3350669b0628bf54a4771512a55f135">operator+=</a> (<a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> init)</td></tr>
<tr class="memdesc:ae3350669b0628bf54a4771512a55f135"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="classbasic__json.html#ae3350669b0628bf54a4771512a55f135">More...</a><br /></td></tr>
<tr class="separator:ae3350669b0628bf54a4771512a55f135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad89dd8715111483428ecf8534b9393"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a7ad89dd8715111483428ecf8534b9393"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7ad89dd8715111483428ecf8534b9393">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7ad89dd8715111483428ecf8534b9393"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classbasic__json.html#a7ad89dd8715111483428ecf8534b9393">More...</a><br /></td></tr>
<tr class="separator:a7ad89dd8715111483428ecf8534b9393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e70795da670f11ad7925407d0a7d83c"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a3e70795da670f11ad7925407d0a7d83c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3e70795da670f11ad7925407d0a7d83c">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3e70795da670f11ad7925407d0a7d83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object if key does not exist  <a href="classbasic__json.html#a3e70795da670f11ad7925407d0a7d83c">More...</a><br /></td></tr>
<tr class="separator:a3e70795da670f11ad7925407d0a7d83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6940b08bda32ce195a9e4508b8aa1126"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6940b08bda32ce195a9e4508b8aa1126"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6940b08bda32ce195a9e4508b8aa1126">insert_iterator</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6940b08bda32ce195a9e4508b8aa1126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for insertion of an iterator.  <a href="classbasic__json.html#a6940b08bda32ce195a9e4508b8aa1126">More...</a><br /></td></tr>
<tr class="separator:a6940b08bda32ce195a9e4508b8aa1126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4467ec0c7679150140f9d2f85e95bf4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4467ec0c7679150140f9d2f85e95bf4b">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a4467ec0c7679150140f9d2f85e95bf4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts element into array  <a href="classbasic__json.html#a4467ec0c7679150140f9d2f85e95bf4b">More...</a><br /></td></tr>
<tr class="separator:a4467ec0c7679150140f9d2f85e95bf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd6ab85d95fa08d0fbce5f957834f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5cd6ab85d95fa08d0fbce5f957834f28">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, <a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a5cd6ab85d95fa08d0fbce5f957834f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts element into array  <a href="classbasic__json.html#a5cd6ab85d95fa08d0fbce5f957834f28">More...</a><br /></td></tr>
<tr class="separator:a5cd6ab85d95fa08d0fbce5f957834f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7b302f4e6249b8b28dcfbebd934600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1d7b302f4e6249b8b28dcfbebd934600">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> cnt, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a1d7b302f4e6249b8b28dcfbebd934600"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts copies of element into array  <a href="classbasic__json.html#a1d7b302f4e6249b8b28dcfbebd934600">More...</a><br /></td></tr>
<tr class="separator:a1d7b302f4e6249b8b28dcfbebd934600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30d7fc224999adeaa9e4dcd81db0f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af30d7fc224999adeaa9e4dcd81db0f05">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> first, <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> last)</td></tr>
<tr class="memdesc:af30d7fc224999adeaa9e4dcd81db0f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts range of elements into array  <a href="classbasic__json.html#af30d7fc224999adeaa9e4dcd81db0f05">More...</a><br /></td></tr>
<tr class="separator:af30d7fc224999adeaa9e4dcd81db0f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b25eeb503c9f30322b966af0451da38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3b25eeb503c9f30322b966af0451da38">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> ilist)</td></tr>
<tr class="memdesc:a3b25eeb503c9f30322b966af0451da38"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts elements from initializer list into array  <a href="classbasic__json.html#a3b25eeb503c9f30322b966af0451da38">More...</a><br /></td></tr>
<tr class="separator:a3b25eeb503c9f30322b966af0451da38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797b7b5589862535c88b9604c88d8d3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a797b7b5589862535c88b9604c88d8d3e">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> first, <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> last)</td></tr>
<tr class="memdesc:a797b7b5589862535c88b9604c88d8d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts range of elements into object  <a href="classbasic__json.html#a797b7b5589862535c88b9604c88d8d3e">More...</a><br /></td></tr>
<tr class="separator:a797b7b5589862535c88b9604c88d8d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c13ddcc1eb615dc56ebd7cb44791bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa1c13ddcc1eb615dc56ebd7cb44791bd">update</a> (<a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> j, bool merge_objects=false)</td></tr>
<tr class="memdesc:aa1c13ddcc1eb615dc56ebd7cb44791bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a JSON object from another object, overwriting existing keys  <a href="classbasic__json.html#aa1c13ddcc1eb615dc56ebd7cb44791bd">More...</a><br /></td></tr>
<tr class="separator:aa1c13ddcc1eb615dc56ebd7cb44791bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db7c9bf454f893d156a7396d527873b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2db7c9bf454f893d156a7396d527873b">update</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> first, <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> last, bool merge_objects=false)</td></tr>
<tr class="memdesc:a2db7c9bf454f893d156a7396d527873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a JSON object from another object, overwriting existing keys  <a href="classbasic__json.html#a2db7c9bf454f893d156a7396d527873b">More...</a><br /></td></tr>
<tr class="separator:a2db7c9bf454f893d156a7396d527873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57541a1c736f6ea94fe4a92dd61b3c37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a57541a1c736f6ea94fe4a92dd61b3c37">swap</a> (<a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>)</td></tr>
<tr class="memdesc:a57541a1c736f6ea94fe4a92dd61b3c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#a57541a1c736f6ea94fe4a92dd61b3c37">More...</a><br /></td></tr>
<tr class="separator:a57541a1c736f6ea94fe4a92dd61b3c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bc171c2ec496dcc63c9035354d1138"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af1bc171c2ec496dcc63c9035354d1138">swap</a> (<a class="el" href="classbasic__json.html#a7cf28eb944e7c06aa47f0bc3a9d6f454">array_t</a> &amp;other)</td></tr>
<tr class="memdesc:af1bc171c2ec496dcc63c9035354d1138"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#af1bc171c2ec496dcc63c9035354d1138">More...</a><br /></td></tr>
<tr class="separator:af1bc171c2ec496dcc63c9035354d1138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2061fc20992f76b6fe4a7d2456391b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2061fc20992f76b6fe4a7d2456391b8f">swap</a> (<a class="el" href="classbasic__json.html#a770279b71f788fe3f76411eedf5b1956">object_t</a> &amp;other)</td></tr>
<tr class="memdesc:a2061fc20992f76b6fe4a7d2456391b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#a2061fc20992f76b6fe4a7d2456391b8f">More...</a><br /></td></tr>
<tr class="separator:a2061fc20992f76b6fe4a7d2456391b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa914de665383b10bdd6265e6b63b8d93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa914de665383b10bdd6265e6b63b8d93">swap</a> (<a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a> &amp;other)</td></tr>
<tr class="memdesc:aa914de665383b10bdd6265e6b63b8d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#aa914de665383b10bdd6265e6b63b8d93">More...</a><br /></td></tr>
<tr class="separator:aa914de665383b10bdd6265e6b63b8d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23296c72c9f837e20cfdc28d8018dd57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a23296c72c9f837e20cfdc28d8018dd57">swap</a> (<a class="el" href="classbasic__json.html#a10e4e8a0166fd47c006b82b20b2dcd7f">binary_t</a> &amp;other)</td></tr>
<tr class="memdesc:a23296c72c9f837e20cfdc28d8018dd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#a23296c72c9f837e20cfdc28d8018dd57">More...</a><br /></td></tr>
<tr class="separator:a23296c72c9f837e20cfdc28d8018dd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636ae0a887a94436f43f26c94aa1f748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a636ae0a887a94436f43f26c94aa1f748">swap</a> (typename binary_t::container_type &amp;other)</td></tr>
<tr class="memdesc:a636ae0a887a94436f43f26c94aa1f748"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#a636ae0a887a94436f43f26c94aa1f748">More...</a><br /></td></tr>
<tr class="separator:a636ae0a887a94436f43f26c94aa1f748"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">lexicographical comparison operators</h2></td></tr>
<tr class="memitem:a39b01253ca65e8f5abdc1796d6ee0012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macro__scope_8h.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a39b01253ca65e8f5abdc1796d6ee0012">__pad2__</a>: static bool compares_unordered(<a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> lhs</td></tr>
<tr class="separator:a39b01253ca65e8f5abdc1796d6ee0012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83f2e1cec130719f862008b9e16acee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macro__scope_8h.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac83f2e1cec130719f862008b9e16acee">rhs</a></td></tr>
<tr class="separator:ac83f2e1cec130719f862008b9e16acee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6a2b3e624ac8772519963bcfb8fb56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macro__scope_8h.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abe6a2b3e624ac8772519963bcfb8fb56">inverse</a></td></tr>
<tr class="separator:abe6a2b3e624ac8772519963bcfb8fb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">value access</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >Direct access to the stored value of a JSON value. </p>
</td></tr>
<tr class="memitem:a206a3748ff1fc676f64f753e203388dd"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a206a3748ff1fc676f64f753e203388dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a206a3748ff1fc676f64f753e203388dd">get_ptr</a> () noexcept -&gt; decltype(std::declval&lt; basic_json_t &amp; &gt;().get_impl_ptr(std::declval&lt; PointerType &gt;()))</td></tr>
<tr class="memdesc:a206a3748ff1fc676f64f753e203388dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (implicit)  <a href="classbasic__json.html#a206a3748ff1fc676f64f753e203388dd">More...</a><br /></td></tr>
<tr class="separator:a206a3748ff1fc676f64f753e203388dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2055fcc0c999d3cb4c211f258695faff"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_const&lt; typename std::remove_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a2055fcc0c999d3cb4c211f258695faff"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2055fcc0c999d3cb4c211f258695faff">get_ptr</a> () const noexcept -&gt; decltype(std::declval&lt; const basic_json_t &amp; &gt;().get_impl_ptr(std::declval&lt; PointerType &gt;()))</td></tr>
<tr class="memdesc:a2055fcc0c999d3cb4c211f258695faff"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (implicit)  <a href="classbasic__json.html#a2055fcc0c999d3cb4c211f258695faff">More...</a><br /></td></tr>
<tr class="separator:a2055fcc0c999d3cb4c211f258695faff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11bff397526e8255d151066caeba48e"><td class="memTemplParams" colspan="2">template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;&gt; </td></tr>
<tr class="memitem:ab11bff397526e8255d151066caeba48e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab11bff397526e8255d151066caeba48e">get</a> () const noexcept(noexcept(std::declval&lt; const basic_json_t &amp; &gt;().template get_impl&lt; ValueType &gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt; {}))) -&gt; decltype(std::declval&lt; const basic_json_t &amp; &gt;().template get_impl&lt; ValueType &gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt; {}))</td></tr>
<tr class="memdesc:ab11bff397526e8255d151066caeba48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a (pointer) value (explicit)  <a href="classbasic__json.html#ab11bff397526e8255d151066caeba48e">More...</a><br /></td></tr>
<tr class="separator:ab11bff397526e8255d151066caeba48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fa19a3f6193409abe4bd9014712105"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a35fa19a3f6193409abe4bd9014712105"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a35fa19a3f6193409abe4bd9014712105">get</a> () noexcept -&gt; decltype(std::declval&lt; basic_json_t &amp; &gt;().template <a class="el" href="classbasic__json.html#a206a3748ff1fc676f64f753e203388dd">get_ptr</a>&lt; PointerType &gt;())</td></tr>
<tr class="memdesc:a35fa19a3f6193409abe4bd9014712105"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (explicit)  <a href="classbasic__json.html#a35fa19a3f6193409abe4bd9014712105">More...</a><br /></td></tr>
<tr class="separator:a35fa19a3f6193409abe4bd9014712105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251b2b7f275328615aed5a0f827e7710"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; !<a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;<a class="el" href="structdetail_1_1has__from__json.html">detail::has_from_json</a>&lt; basic_json_t, ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a251b2b7f275328615aed5a0f827e7710"><td class="memTemplItemLeft" align="right" valign="top">ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a251b2b7f275328615aed5a0f827e7710">get_to</a> (ValueType &amp;v) const noexcept(noexcept(JSONSerializer&lt; ValueType &gt;::from_json(std::declval&lt; const basic_json_t &amp; &gt;(), v)))</td></tr>
<tr class="memdesc:a251b2b7f275328615aed5a0f827e7710"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a value (explicit)  <a href="classbasic__json.html#a251b2b7f275328615aed5a0f827e7710">More...</a><br /></td></tr>
<tr class="separator:a251b2b7f275328615aed5a0f827e7710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0131c192963ed4d1148805120aa319"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9e0131c192963ed4d1148805120aa319"><td class="memTemplItemLeft" align="right" valign="top">ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9e0131c192963ed4d1148805120aa319">get_to</a> (ValueType &amp;v) const</td></tr>
<tr class="separator:a9e0131c192963ed4d1148805120aa319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a78b37dee5a709f610375403597bba"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename Array  = T (&amp;)[N], <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1has__from__json.html">detail::has_from_json</a>&lt; basic_json_t, Array &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac6a78b37dee5a709f610375403597bba"><td class="memTemplItemLeft" align="right" valign="top">Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac6a78b37dee5a709f610375403597bba">get_to</a> (T(&amp;v)[N]) const noexcept(noexcept(JSONSerializer&lt; Array &gt;::from_json(std::declval&lt; const basic_json_t &amp; &gt;(), v)))</td></tr>
<tr class="separator:ac6a78b37dee5a709f610375403597bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfdaa5014da75e18dd07cc76e53b237"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a7bfdaa5014da75e18dd07cc76e53b237"><td class="memTemplItemLeft" align="right" valign="top">ReferenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7bfdaa5014da75e18dd07cc76e53b237">get_ref</a> ()</td></tr>
<tr class="memdesc:a7bfdaa5014da75e18dd07cc76e53b237"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference value (implicit)  <a href="classbasic__json.html#a7bfdaa5014da75e18dd07cc76e53b237">More...</a><br /></td></tr>
<tr class="separator:a7bfdaa5014da75e18dd07cc76e53b237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f1f9cf90ed5254e38e6b587fce237d"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_const&lt; typename std::remove_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a42f1f9cf90ed5254e38e6b587fce237d"><td class="memTemplItemLeft" align="right" valign="top">ReferenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a42f1f9cf90ed5254e38e6b587fce237d">get_ref</a> () const</td></tr>
<tr class="memdesc:a42f1f9cf90ed5254e38e6b587fce237d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference value (implicit)  <a href="classbasic__json.html#a42f1f9cf90ed5254e38e6b587fce237d">More...</a><br /></td></tr>
<tr class="separator:a42f1f9cf90ed5254e38e6b587fce237d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ccb49215a3dcac15438fb94485e86f"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename std::enable_if&lt; <a class="el" href="structdetail_1_1conjunction.html">detail::conjunction</a>&lt; <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_pointer&lt; ValueType &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, std::nullptr_t &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, <a class="el" href="classdetail_1_1json__ref.html">detail::json_ref</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, typename string_t::value_type &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, std::initializer_list&lt; typename string_t::value_type &gt; &gt; &gt;, <a class="el" href="structdetail_1_1is__detected__lazy.html">detail::is_detected_lazy</a>&lt; <a class="el" href="namespacedetail.html#a34780011ee13a3ede041ddcee288f484">detail::get_template_function</a>, const basic_json_t &amp;, ValueType &gt; &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a31ccb49215a3dcac15438fb94485e86f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="macro__scope_8h.html#aefed8cf27cadeea45f12c6f3db3ce774">JSON_EXPLICIT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a31ccb49215a3dcac15438fb94485e86f">operator ValueType</a> () const</td></tr>
<tr class="memdesc:a31ccb49215a3dcac15438fb94485e86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a value (implicit)  <a href="classbasic__json.html#a31ccb49215a3dcac15438fb94485e86f">More...</a><br /></td></tr>
<tr class="separator:a31ccb49215a3dcac15438fb94485e86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4401911681258520903f3c374a9e994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a10e4e8a0166fd47c006b82b20b2dcd7f">binary_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa4401911681258520903f3c374a9e994">get_binary</a> ()</td></tr>
<tr class="memdesc:aa4401911681258520903f3c374a9e994"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a binary value  <a href="classbasic__json.html#aa4401911681258520903f3c374a9e994">More...</a><br /></td></tr>
<tr class="separator:aa4401911681258520903f3c374a9e994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b4244ff0e901156adfad7b027232de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbasic__json.html#a10e4e8a0166fd47c006b82b20b2dcd7f">binary_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a44b4244ff0e901156adfad7b027232de">get_binary</a> () const</td></tr>
<tr class="memdesc:a44b4244ff0e901156adfad7b027232de"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a binary value  <a href="classbasic__json.html#a44b4244ff0e901156adfad7b027232de">More...</a><br /></td></tr>
<tr class="separator:a44b4244ff0e901156adfad7b027232de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">constructors and destructors</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >Constructors of class <a class="el" href="classbasic__json.html">basic_json</a>, copy/move constructor, copy assignment, static functions creating objects, and the destructor. </p>
</td></tr>
<tr class="memitem:a8d25b7a4a6f6ee355193ee6b461ab3bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8d25b7a4a6f6ee355193ee6b461ab3bd">binary</a> (const typename binary_t::container_type &amp;init)</td></tr>
<tr class="memdesc:a8d25b7a4a6f6ee355193ee6b461ab3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classbasic__json.html#a8d25b7a4a6f6ee355193ee6b461ab3bd">More...</a><br /></td></tr>
<tr class="separator:a8d25b7a4a6f6ee355193ee6b461ab3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a92f5028b858b39e0c49c722ba09793"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9a92f5028b858b39e0c49c722ba09793">binary</a> (const typename binary_t::container_type &amp;init, typename binary_t::subtype_type subtype)</td></tr>
<tr class="memdesc:a9a92f5028b858b39e0c49c722ba09793"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (with subtype)  <a href="classbasic__json.html#a9a92f5028b858b39e0c49c722ba09793">More...</a><br /></td></tr>
<tr class="separator:a9a92f5028b858b39e0c49c722ba09793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0767ec4050ecfb4e4852db24cc939b2b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0767ec4050ecfb4e4852db24cc939b2b">binary</a> (typename binary_t::container_type &amp;&amp;init)</td></tr>
<tr class="memdesc:a0767ec4050ecfb4e4852db24cc939b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array  <a href="classbasic__json.html#a0767ec4050ecfb4e4852db24cc939b2b">More...</a><br /></td></tr>
<tr class="separator:a0767ec4050ecfb4e4852db24cc939b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad9ba515c5f51d9c5609583e3d0ada0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6ad9ba515c5f51d9c5609583e3d0ada0">binary</a> (typename binary_t::container_type &amp;&amp;init, typename binary_t::subtype_type subtype)</td></tr>
<tr class="memdesc:a6ad9ba515c5f51d9c5609583e3d0ada0"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (with subtype)  <a href="classbasic__json.html#a6ad9ba515c5f51d9c5609583e3d0ada0">More...</a><br /></td></tr>
<tr class="separator:a6ad9ba515c5f51d9c5609583e3d0ada0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a68350d457af1f6ea7f27b6e0a5baf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a08a68350d457af1f6ea7f27b6e0a5baf">array</a> (<a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> init={})</td></tr>
<tr class="memdesc:a08a68350d457af1f6ea7f27b6e0a5baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create an array from an initializer list  <a href="classbasic__json.html#a08a68350d457af1f6ea7f27b6e0a5baf">More...</a><br /></td></tr>
<tr class="separator:a08a68350d457af1f6ea7f27b6e0a5baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aa3ec9e58f6852709913408519c01c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a10aa3ec9e58f6852709913408519c01c">object</a> (<a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> init={})</td></tr>
<tr class="memdesc:a10aa3ec9e58f6852709913408519c01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create an object from an initializer list  <a href="classbasic__json.html#a10aa3ec9e58f6852709913408519c01c">More...</a><br /></td></tr>
<tr class="separator:a10aa3ec9e58f6852709913408519c01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee75ecbdc67fc5faa1228c949c59ff27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aee75ecbdc67fc5faa1228c949c59ff27">basic_json</a> (const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> v)</td></tr>
<tr class="memdesc:aee75ecbdc67fc5faa1228c949c59ff27"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an empty value with a given type  <a href="classbasic__json.html#aee75ecbdc67fc5faa1228c949c59ff27">More...</a><br /></td></tr>
<tr class="separator:aee75ecbdc67fc5faa1228c949c59ff27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f1bad4745ddb574540f71cdbcd532f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac6f1bad4745ddb574540f71cdbcd532f">basic_json</a> (std::nullptr_t=nullptr) noexcept</td></tr>
<tr class="memdesc:ac6f1bad4745ddb574540f71cdbcd532f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a null object  <a href="classbasic__json.html#ac6f1bad4745ddb574540f71cdbcd532f">More...</a><br /></td></tr>
<tr class="separator:ac6f1bad4745ddb574540f71cdbcd532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1f9ac7c7ebcff72d00869e974a6249"><td class="memTemplParams" colspan="2">template&lt;typename CompatibleType , typename U  = detail::uncvref_t&lt;CompatibleType&gt;, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; !<a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; U &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;<a class="el" href="structdetail_1_1is__compatible__type.html">detail::is_compatible_type</a>&lt; basic_json_t, U &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9b1f9ac7c7ebcff72d00869e974a6249"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9b1f9ac7c7ebcff72d00869e974a6249">basic_json</a> (CompatibleType &amp;&amp;val) noexcept(noexcept(//NOLINT(bugprone-forwarding-<a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>-overload, bugprone-<a class="el" href="classbasic__json.html#ab671bd0e5eef59e58d362e6cd8937633">exception</a>-escape) JSONSerializer&lt; U &gt;::to_json(std::declval&lt; basic_json_t &amp; &gt;(), std::forward&lt; CompatibleType &gt;(val))))</td></tr>
<tr class="memdesc:a9b1f9ac7c7ebcff72d00869e974a6249"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from compatible types  <a href="classbasic__json.html#a9b1f9ac7c7ebcff72d00869e974a6249">More...</a><br /></td></tr>
<tr class="separator:a9b1f9ac7c7ebcff72d00869e974a6249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94560a1edd72d60310c54c9b2d9f1ad2"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;!std::is_same&lt; <a class="el" href="classbasic__json.html">basic_json</a>, BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a94560a1edd72d60310c54c9b2d9f1ad2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a94560a1edd72d60310c54c9b2d9f1ad2">basic_json</a> (const BasicJsonType &amp;val)</td></tr>
<tr class="memdesc:a94560a1edd72d60310c54c9b2d9f1ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an existing one  <a href="classbasic__json.html#a94560a1edd72d60310c54c9b2d9f1ad2">More...</a><br /></td></tr>
<tr class="separator:a94560a1edd72d60310c54c9b2d9f1ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3d71dec8062753efb67860b7cca1a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aec3d71dec8062753efb67860b7cca1a1">basic_json</a> (<a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> init, bool type_deduction=true, <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> manual_type=<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>)</td></tr>
<tr class="memdesc:aec3d71dec8062753efb67860b7cca1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a container (array or object) from an initializer list  <a href="classbasic__json.html#aec3d71dec8062753efb67860b7cca1a1">More...</a><br /></td></tr>
<tr class="separator:aec3d71dec8062753efb67860b7cca1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad382c9c9e03c410004150c9d6b9f0bd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad382c9c9e03c410004150c9d6b9f0bd9">basic_json</a> (<a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> cnt, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:ad382c9c9e03c410004150c9d6b9f0bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct an array with count copies of given value  <a href="classbasic__json.html#ad382c9c9e03c410004150c9d6b9f0bd9">More...</a><br /></td></tr>
<tr class="separator:ad382c9c9e03c410004150c9d6b9f0bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f2c1a11dd6e84196132ea77a99572a"><td class="memTemplParams" colspan="2">template&lt;class InputIT , typename std::enable_if&lt; std::is_same&lt; InputIT, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; InputIT, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a12f2c1a11dd6e84196132ea77a99572a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a12f2c1a11dd6e84196132ea77a99572a">basic_json</a> (InputIT first, InputIT last)</td></tr>
<tr class="memdesc:a12f2c1a11dd6e84196132ea77a99572a"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a JSON container given an iterator range  <a href="classbasic__json.html#a12f2c1a11dd6e84196132ea77a99572a">More...</a><br /></td></tr>
<tr class="separator:a12f2c1a11dd6e84196132ea77a99572a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33adf04c1d841c42c0eeaf05252aedc3"><td class="memTemplParams" colspan="2">template&lt;typename JsonRef , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1conjunction.html">detail::conjunction</a>&lt; <a class="el" href="structdetail_1_1is__json__ref.html">detail::is_json_ref</a>&lt; JsonRef &gt;, std::is_same&lt; typename JsonRef::value_type, <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a33adf04c1d841c42c0eeaf05252aedc3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a33adf04c1d841c42c0eeaf05252aedc3">basic_json</a> (const JsonRef &amp;ref)</td></tr>
<tr class="separator:a33adf04c1d841c42c0eeaf05252aedc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62e476c88b91f1f4329bb4901cafc4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac62e476c88b91f1f4329bb4901cafc4c">basic_json</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;other)</td></tr>
<tr class="memdesc:ac62e476c88b91f1f4329bb4901cafc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classbasic__json.html#ac62e476c88b91f1f4329bb4901cafc4c">More...</a><br /></td></tr>
<tr class="separator:ac62e476c88b91f1f4329bb4901cafc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa269ba998ca2e15b2f596a8c074d125f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa269ba998ca2e15b2f596a8c074d125f">basic_json</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aa269ba998ca2e15b2f596a8c074d125f"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="classbasic__json.html#aa269ba998ca2e15b2f596a8c074d125f">More...</a><br /></td></tr>
<tr class="separator:aa269ba998ca2e15b2f596a8c074d125f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb70d0ea0c23ac40f1f3b67d40c174f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html">basic_json</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8cb70d0ea0c23ac40f1f3b67d40c174f">operator=</a> (<a class="el" href="classbasic__json.html">basic_json</a> other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>)</td></tr>
<tr class="memdesc:a8cb70d0ea0c23ac40f1f3b67d40c174f"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assignment  <a href="classbasic__json.html#a8cb70d0ea0c23ac40f1f3b67d40c174f">More...</a><br /></td></tr>
<tr class="separator:a8cb70d0ea0c23ac40f1f3b67d40c174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0209408ec1ed66ea5f89a7d72e57e43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad0209408ec1ed66ea5f89a7d72e57e43">~basic_json</a> () noexcept</td></tr>
<tr class="memdesc:ad0209408ec1ed66ea5f89a7d72e57e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="classbasic__json.html#ad0209408ec1ed66ea5f89a7d72e57e43">More...</a><br /></td></tr>
<tr class="separator:ad0209408ec1ed66ea5f89a7d72e57e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">binary serialization/deserialization support</h2></td></tr>
<tr class="memitem:a12a270a8c98f23f838837562ddde18a8"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a12a270a8c98f23f838837562ddde18a8">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:a12a270a8c98f23f838837562ddde18a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <a href="classbasic__json.html#a12a270a8c98f23f838837562ddde18a8">More...</a><br /></td></tr>
<tr class="separator:a12a270a8c98f23f838837562ddde18a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e6116b577c4a402d0bf59ceb1ce3b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a91e6116b577c4a402d0bf59ceb1ce3b6">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:a91e6116b577c4a402d0bf59ceb1ce3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <a href="classbasic__json.html#a91e6116b577c4a402d0bf59ceb1ce3b6">More...</a><br /></td></tr>
<tr class="separator:a91e6116b577c4a402d0bf59ceb1ce3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b49f22c2c0ed2c803c695f328ee5f4f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4b49f22c2c0ed2c803c695f328ee5f4f">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:a4b49f22c2c0ed2c803c695f328ee5f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <a href="classbasic__json.html#a4b49f22c2c0ed2c803c695f328ee5f4f">More...</a><br /></td></tr>
<tr class="separator:a4b49f22c2c0ed2c803c695f328ee5f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d510f5c39b036deb96e61c8bef19f31"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4d510f5c39b036deb96e61c8bef19f31">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:a4d510f5c39b036deb96e61c8bef19f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <a href="classbasic__json.html#a4d510f5c39b036deb96e61c8bef19f31">More...</a><br /></td></tr>
<tr class="separator:a4d510f5c39b036deb96e61c8bef19f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91a270a87e6aec97c18d44aaddf0d33"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad91a270a87e6aec97c18d44aaddf0d33">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:ad91a270a87e6aec97c18d44aaddf0d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <a href="classbasic__json.html#ad91a270a87e6aec97c18d44aaddf0d33">More...</a><br /></td></tr>
<tr class="separator:ad91a270a87e6aec97c18d44aaddf0d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3ec809212107cb5809c386c5e3dce3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7e3ec809212107cb5809c386c5e3dce3">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:a7e3ec809212107cb5809c386c5e3dce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <a href="classbasic__json.html#a7e3ec809212107cb5809c386c5e3dce3">More...</a><br /></td></tr>
<tr class="separator:a7e3ec809212107cb5809c386c5e3dce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a0e7569fb3170e0151e4aca3f4bf3b"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a74a0e7569fb3170e0151e4aca3f4bf3b">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a74a0e7569fb3170e0151e4aca3f4bf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <a href="classbasic__json.html#a74a0e7569fb3170e0151e4aca3f4bf3b">More...</a><br /></td></tr>
<tr class="separator:a74a0e7569fb3170e0151e4aca3f4bf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7567f6b4b51d3bc1cbe6a80cd6ca9a8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad7567f6b4b51d3bc1cbe6a80cd6ca9a8">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:ad7567f6b4b51d3bc1cbe6a80cd6ca9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <a href="classbasic__json.html#ad7567f6b4b51d3bc1cbe6a80cd6ca9a8">More...</a><br /></td></tr>
<tr class="separator:ad7567f6b4b51d3bc1cbe6a80cd6ca9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81aecae4901eb995b22ee6abccf94122"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a81aecae4901eb995b22ee6abccf94122">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a81aecae4901eb995b22ee6abccf94122"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <a href="classbasic__json.html#a81aecae4901eb995b22ee6abccf94122">More...</a><br /></td></tr>
<tr class="separator:a81aecae4901eb995b22ee6abccf94122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b222d92f075b0033a76a60ccb36269c"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2b222d92f075b0033a76a60ccb36269c">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a2b222d92f075b0033a76a60ccb36269c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <a href="classbasic__json.html#a2b222d92f075b0033a76a60ccb36269c">More...</a><br /></td></tr>
<tr class="separator:a2b222d92f075b0033a76a60ccb36269c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4a7117f98423b6d92e48951a7e3c55"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9b4a7117f98423b6d92e48951a7e3c55">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a9b4a7117f98423b6d92e48951a7e3c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <a href="classbasic__json.html#a9b4a7117f98423b6d92e48951a7e3c55">More...</a><br /></td></tr>
<tr class="separator:a9b4a7117f98423b6d92e48951a7e3c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c66ff3a69ef4e4d0d1c136d4226c6af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9c66ff3a69ef4e4d0d1c136d4226c6af">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a9c66ff3a69ef4e4d0d1c136d4226c6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <a href="classbasic__json.html#a9c66ff3a69ef4e4d0d1c136d4226c6af">More...</a><br /></td></tr>
<tr class="separator:a9c66ff3a69ef4e4d0d1c136d4226c6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f418313f92075a0ab72060bfe4de06"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a85f418313f92075a0ab72060bfe4de06">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:a85f418313f92075a0ab72060bfe4de06"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <a href="classbasic__json.html#a85f418313f92075a0ab72060bfe4de06">More...</a><br /></td></tr>
<tr class="separator:a85f418313f92075a0ab72060bfe4de06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ff725ab08638fbc83ed7e3c7c41396"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad5ff725ab08638fbc83ed7e3c7c41396">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:ad5ff725ab08638fbc83ed7e3c7c41396"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <a href="classbasic__json.html#ad5ff725ab08638fbc83ed7e3c7c41396">More...</a><br /></td></tr>
<tr class="separator:ad5ff725ab08638fbc83ed7e3c7c41396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bb643538ab0e016a2f319e22bf4c4d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a62bb643538ab0e016a2f319e22bf4c4d">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:a62bb643538ab0e016a2f319e22bf4c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <a href="classbasic__json.html#a62bb643538ab0e016a2f319e22bf4c4d">More...</a><br /></td></tr>
<tr class="separator:a62bb643538ab0e016a2f319e22bf4c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e2d9cbd8a385017bb3d91c45a1753a"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a84e2d9cbd8a385017bb3d91c45a1753a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a84e2d9cbd8a385017bb3d91c45a1753a">from_cbor</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="memdesc:a84e2d9cbd8a385017bb3d91c45a1753a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in CBOR format  <a href="classbasic__json.html#a84e2d9cbd8a385017bb3d91c45a1753a">More...</a><br /></td></tr>
<tr class="separator:a84e2d9cbd8a385017bb3d91c45a1753a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93872bc620a9bbe028be81a3eaae21f3"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a93872bc620a9bbe028be81a3eaae21f3"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a93872bc620a9bbe028be81a3eaae21f3">from_cbor</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="memdesc:a93872bc620a9bbe028be81a3eaae21f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in CBOR format  <a href="classbasic__json.html#a93872bc620a9bbe028be81a3eaae21f3">More...</a><br /></td></tr>
<tr class="separator:a93872bc620a9bbe028be81a3eaae21f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcdc5f7b4a7ebf4b2a1a21710ad246d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0dcdc5f7b4a7ebf4b2a1a21710ad246d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0dcdc5f7b4a7ebf4b2a1a21710ad246d">from_cbor</a> (const T *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>, std::size_t len, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="separator:a0dcdc5f7b4a7ebf4b2a1a21710ad246d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff52051e3e569f6f801b2d7b66124b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#adff52051e3e569f6f801b2d7b66124b1">from_cbor</a> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="separator:adff52051e3e569f6f801b2d7b66124b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ba0ffab9429d589d658d3e053b8273"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a96ba0ffab9429d589d658d3e053b8273"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a96ba0ffab9429d589d658d3e053b8273">from_msgpack</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a96ba0ffab9429d589d658d3e053b8273"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in MessagePack format  <a href="classbasic__json.html#a96ba0ffab9429d589d658d3e053b8273">More...</a><br /></td></tr>
<tr class="separator:a96ba0ffab9429d589d658d3e053b8273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3794747f5b19e0504afa3585476e97"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a7f3794747f5b19e0504afa3585476e97"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7f3794747f5b19e0504afa3585476e97">from_msgpack</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a7f3794747f5b19e0504afa3585476e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in MessagePack format  <a href="classbasic__json.html#a7f3794747f5b19e0504afa3585476e97">More...</a><br /></td></tr>
<tr class="separator:a7f3794747f5b19e0504afa3585476e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac347f43d4eb713aa711d6c8a5fca41cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac347f43d4eb713aa711d6c8a5fca41cf"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac347f43d4eb713aa711d6c8a5fca41cf">from_msgpack</a> (const T *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:ac347f43d4eb713aa711d6c8a5fca41cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a29d7be59d39991efb3a584cd2e6598"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2a29d7be59d39991efb3a584cd2e6598">from_msgpack</a> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a2a29d7be59d39991efb3a584cd2e6598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662ee4905d8c2628b3018b378bbd4c9e"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a662ee4905d8c2628b3018b378bbd4c9e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a662ee4905d8c2628b3018b378bbd4c9e">from_ubjson</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a662ee4905d8c2628b3018b378bbd4c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in UBJSON format  <a href="classbasic__json.html#a662ee4905d8c2628b3018b378bbd4c9e">More...</a><br /></td></tr>
<tr class="separator:a662ee4905d8c2628b3018b378bbd4c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36123b583eaae095ee46413e4e380ef"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:ad36123b583eaae095ee46413e4e380ef"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad36123b583eaae095ee46413e4e380ef">from_ubjson</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:ad36123b583eaae095ee46413e4e380ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in UBJSON format  <a href="classbasic__json.html#ad36123b583eaae095ee46413e4e380ef">More...</a><br /></td></tr>
<tr class="separator:ad36123b583eaae095ee46413e4e380ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5a903e9aad342917fc3e98c070a0d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d5a903e9aad342917fc3e98c070a0d7"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3d5a903e9aad342917fc3e98c070a0d7">from_ubjson</a> (const T *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a3d5a903e9aad342917fc3e98c070a0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99be0ee4212c46c20ee32d4a1a90cc6c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a99be0ee4212c46c20ee32d4a1a90cc6c">from_ubjson</a> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a99be0ee4212c46c20ee32d4a1a90cc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affeac471308bec4cfe026258f746cfcc"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:affeac471308bec4cfe026258f746cfcc"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#affeac471308bec4cfe026258f746cfcc">from_bjdata</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:affeac471308bec4cfe026258f746cfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BJData format  <a href="classbasic__json.html#affeac471308bec4cfe026258f746cfcc">More...</a><br /></td></tr>
<tr class="separator:affeac471308bec4cfe026258f746cfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c00d3023a03b37d9a362cdf61c17c1"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a94c00d3023a03b37d9a362cdf61c17c1"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a94c00d3023a03b37d9a362cdf61c17c1">from_bjdata</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a94c00d3023a03b37d9a362cdf61c17c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BJData format  <a href="classbasic__json.html#a94c00d3023a03b37d9a362cdf61c17c1">More...</a><br /></td></tr>
<tr class="separator:a94c00d3023a03b37d9a362cdf61c17c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac8b0effce93dad2e3eec9c1a7ed129"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a5ac8b0effce93dad2e3eec9c1a7ed129"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5ac8b0effce93dad2e3eec9c1a7ed129">from_bson</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a5ac8b0effce93dad2e3eec9c1a7ed129"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BSON format  <a href="classbasic__json.html#a5ac8b0effce93dad2e3eec9c1a7ed129">More...</a><br /></td></tr>
<tr class="separator:a5ac8b0effce93dad2e3eec9c1a7ed129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c87b306915435958b5e584dfb80ce4"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a06c87b306915435958b5e584dfb80ce4"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a06c87b306915435958b5e584dfb80ce4">from_bson</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a06c87b306915435958b5e584dfb80ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BSON format  <a href="classbasic__json.html#a06c87b306915435958b5e584dfb80ce4">More...</a><br /></td></tr>
<tr class="separator:a06c87b306915435958b5e584dfb80ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d6a52ae542b7ffd137e87e72f9bcce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5d6a52ae542b7ffd137e87e72f9bcce"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa5d6a52ae542b7ffd137e87e72f9bcce">from_bson</a> (const T *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:aa5d6a52ae542b7ffd137e87e72f9bcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868a32e0da318e39872fb825b377bda6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a868a32e0da318e39872fb825b377bda6">from_bson</a> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a868a32e0da318e39872fb825b377bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Patch functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >return flattened JSON value</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/flatten/">https://json.nlohmann.me/api/basic_json/flatten/</a></dd></dl>
<p>unflatten a previously flattened JSON value </p><dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/unflatten/">https://json.nlohmann.me/api/basic_json/unflatten/</a> </dd></dl>
</td></tr>
<tr class="memitem:aff2204c04cd35b2cef35f44b2b93ffc7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aff2204c04cd35b2cef35f44b2b93ffc7">diff</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;<a class="el" href="_third_party_notices_8txt.html#a7e4b2af6b1063d628370e894227dec10">source</a>, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;target, const std::string &amp;path=&quot;&quot;)</td></tr>
<tr class="memdesc:aff2204c04cd35b2cef35f44b2b93ffc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a diff as a JSON patch  <a href="classbasic__json.html#aff2204c04cd35b2cef35f44b2b93ffc7">More...</a><br /></td></tr>
<tr class="separator:aff2204c04cd35b2cef35f44b2b93ffc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a009b55b9dcdb30352f5f62537931b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5a009b55b9dcdb30352f5f62537931b7">patch</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;json_patch) const</td></tr>
<tr class="memdesc:a5a009b55b9dcdb30352f5f62537931b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a JSON patch to a copy of the current object  <a href="classbasic__json.html#a5a009b55b9dcdb30352f5f62537931b7">More...</a><br /></td></tr>
<tr class="separator:a5a009b55b9dcdb30352f5f62537931b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">object inspection</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >Functions to inspect the type of a JSON value. </p>
</td></tr>
<tr class="memitem:ac38b5f79c16205efb771e99be206b345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac38b5f79c16205efb771e99be206b345">dump</a> (const int indent=-1, const char indent_char=' ', const bool ensure_ascii=false, const <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a> error_handler=error_handler_t::strict) const</td></tr>
<tr class="memdesc:ac38b5f79c16205efb771e99be206b345"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialization  <a href="classbasic__json.html#ac38b5f79c16205efb771e99be206b345">More...</a><br /></td></tr>
<tr class="separator:ac38b5f79c16205efb771e99be206b345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24efea87e4dfe02fe67216e3c130dd76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a24efea87e4dfe02fe67216e3c130dd76">dump</a> (raw_ostream &amp;os, const int indent=-1, const char indent_char=' ', const bool ensure_ascii=false, const <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a> error_handler=error_handler_t::strict) const</td></tr>
<tr class="separator:a24efea87e4dfe02fe67216e3c130dd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1338e4eef7282cd57a4a57e034531029"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">type</a> () const noexcept</td></tr>
<tr class="memdesc:a1338e4eef7282cd57a4a57e034531029"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type of the JSON value (explicit)  <a href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">More...</a><br /></td></tr>
<tr class="separator:a1338e4eef7282cd57a4a57e034531029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa8bc506b1519193a7bbc09f8a0f095"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7fa8bc506b1519193a7bbc09f8a0f095">is_primitive</a> () const noexcept</td></tr>
<tr class="memdesc:a7fa8bc506b1519193a7bbc09f8a0f095"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether type is primitive  <a href="classbasic__json.html#a7fa8bc506b1519193a7bbc09f8a0f095">More...</a><br /></td></tr>
<tr class="separator:a7fa8bc506b1519193a7bbc09f8a0f095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded85ec1014821c21b8a47bc816a6917"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aded85ec1014821c21b8a47bc816a6917">is_structured</a> () const noexcept</td></tr>
<tr class="memdesc:aded85ec1014821c21b8a47bc816a6917"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether type is structured  <a href="classbasic__json.html#aded85ec1014821c21b8a47bc816a6917">More...</a><br /></td></tr>
<tr class="separator:aded85ec1014821c21b8a47bc816a6917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed948b2c2e71ce5f5c03b5eeb575df4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a> () const noexcept</td></tr>
<tr class="memdesc:a6ed948b2c2e71ce5f5c03b5eeb575df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is null  <a href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">More...</a><br /></td></tr>
<tr class="separator:a6ed948b2c2e71ce5f5c03b5eeb575df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814771ab0add0def16119c157b44003a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a814771ab0add0def16119c157b44003a">is_boolean</a> () const noexcept</td></tr>
<tr class="memdesc:a814771ab0add0def16119c157b44003a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a boolean  <a href="classbasic__json.html#a814771ab0add0def16119c157b44003a">More...</a><br /></td></tr>
<tr class="separator:a814771ab0add0def16119c157b44003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84294fe5d1a2822e2f67685f6e8c735"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab84294fe5d1a2822e2f67685f6e8c735">is_number</a> () const noexcept</td></tr>
<tr class="memdesc:ab84294fe5d1a2822e2f67685f6e8c735"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a number  <a href="classbasic__json.html#ab84294fe5d1a2822e2f67685f6e8c735">More...</a><br /></td></tr>
<tr class="separator:ab84294fe5d1a2822e2f67685f6e8c735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14438fe7c1f5a2f750eb56b8e73e538"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad14438fe7c1f5a2f750eb56b8e73e538">is_number_integer</a> () const noexcept</td></tr>
<tr class="memdesc:ad14438fe7c1f5a2f750eb56b8e73e538"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an integer number  <a href="classbasic__json.html#ad14438fe7c1f5a2f750eb56b8e73e538">More...</a><br /></td></tr>
<tr class="separator:ad14438fe7c1f5a2f750eb56b8e73e538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5744d3f2404f2376ab0dbe531e4d3bc"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa5744d3f2404f2376ab0dbe531e4d3bc">is_number_unsigned</a> () const noexcept</td></tr>
<tr class="memdesc:aa5744d3f2404f2376ab0dbe531e4d3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an unsigned integer number  <a href="classbasic__json.html#aa5744d3f2404f2376ab0dbe531e4d3bc">More...</a><br /></td></tr>
<tr class="separator:aa5744d3f2404f2376ab0dbe531e4d3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c885a9182fd22b05826ab2a9548f60"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa8c885a9182fd22b05826ab2a9548f60">is_number_float</a> () const noexcept</td></tr>
<tr class="memdesc:aa8c885a9182fd22b05826ab2a9548f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a floating-point number  <a href="classbasic__json.html#aa8c885a9182fd22b05826ab2a9548f60">More...</a><br /></td></tr>
<tr class="separator:aa8c885a9182fd22b05826ab2a9548f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af758a912346776b086abb82487b1d73b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a> () const noexcept</td></tr>
<tr class="memdesc:af758a912346776b086abb82487b1d73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an object  <a href="classbasic__json.html#af758a912346776b086abb82487b1d73b">More...</a><br /></td></tr>
<tr class="separator:af758a912346776b086abb82487b1d73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ea48a4e802ef81783c0c7ce89aa7bb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a> () const noexcept</td></tr>
<tr class="memdesc:a89ea48a4e802ef81783c0c7ce89aa7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an array  <a href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">More...</a><br /></td></tr>
<tr class="separator:a89ea48a4e802ef81783c0c7ce89aa7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4378552d27c9f15e4cb4ff4c075c94"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3d4378552d27c9f15e4cb4ff4c075c94">is_string</a> () const noexcept</td></tr>
<tr class="memdesc:a3d4378552d27c9f15e4cb4ff4c075c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a string  <a href="classbasic__json.html#a3d4378552d27c9f15e4cb4ff4c075c94">More...</a><br /></td></tr>
<tr class="separator:a3d4378552d27c9f15e4cb4ff4c075c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25e81e71e2a263c0431f02f3245a8aa"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa25e81e71e2a263c0431f02f3245a8aa">is_binary</a> () const noexcept</td></tr>
<tr class="memdesc:aa25e81e71e2a263c0431f02f3245a8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a binary array  <a href="classbasic__json.html#aa25e81e71e2a263c0431f02f3245a8aa">More...</a><br /></td></tr>
<tr class="separator:aa25e81e71e2a263c0431f02f3245a8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc7082bb9fa07704c659f6be7c41bc9"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abcc7082bb9fa07704c659f6be7c41bc9">is_discarded</a> () const noexcept</td></tr>
<tr class="memdesc:abcc7082bb9fa07704c659f6be7c41bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is discarded  <a href="classbasic__json.html#abcc7082bb9fa07704c659f6be7c41bc9">More...</a><br /></td></tr>
<tr class="separator:abcc7082bb9fa07704c659f6be7c41bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab025e8b5ac852c84758f92183b569b99"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab025e8b5ac852c84758f92183b569b99">operator value_t</a> () const noexcept</td></tr>
<tr class="memdesc:ab025e8b5ac852c84758f92183b569b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type of the JSON value (implicit)  <a href="classbasic__json.html#ab025e8b5ac852c84758f92183b569b99">More...</a><br /></td></tr>
<tr class="separator:ab025e8b5ac852c84758f92183b569b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">lookup</h2></td></tr>
<tr class="memitem:a8ed11f83edce392fd94659b1102d078e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8ed11f83edce392fd94659b1102d078e">find</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:a8ed11f83edce392fd94659b1102d078e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classbasic__json.html#a8ed11f83edce392fd94659b1102d078e">More...</a><br /></td></tr>
<tr class="separator:a8ed11f83edce392fd94659b1102d078e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8085b05e9a2e6f187708bca5e22d04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8d8085b05e9a2e6f187708bca5e22d04">find</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:a8d8085b05e9a2e6f187708bca5e22d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classbasic__json.html#a8d8085b05e9a2e6f187708bca5e22d04">More...</a><br /></td></tr>
<tr class="separator:a8d8085b05e9a2e6f187708bca5e22d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e01eb7be2878873ba084c0a0b20442"><td class="memTemplParams" colspan="2">template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a81e01eb7be2878873ba084c0a0b20442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a81e01eb7be2878873ba084c0a0b20442">find</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a81e01eb7be2878873ba084c0a0b20442"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classbasic__json.html#a81e01eb7be2878873ba084c0a0b20442">More...</a><br /></td></tr>
<tr class="separator:a81e01eb7be2878873ba084c0a0b20442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42890814a18f9c593f69218706113474"><td class="memTemplParams" colspan="2">template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a42890814a18f9c593f69218706113474"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a42890814a18f9c593f69218706113474">find</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a42890814a18f9c593f69218706113474"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classbasic__json.html#a42890814a18f9c593f69218706113474">More...</a><br /></td></tr>
<tr class="separator:a42890814a18f9c593f69218706113474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac122e03d4d28d6a03c01abaa7229d4c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac122e03d4d28d6a03c01abaa7229d4c7">count</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:ac122e03d4d28d6a03c01abaa7229d4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of occurrences of a key in a JSON object  <a href="classbasic__json.html#ac122e03d4d28d6a03c01abaa7229d4c7">More...</a><br /></td></tr>
<tr class="separator:ac122e03d4d28d6a03c01abaa7229d4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e36a368cbf554fc817b0cb3e37e3a3"><td class="memTemplParams" colspan="2">template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a06e36a368cbf554fc817b0cb3e37e3a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a06e36a368cbf554fc817b0cb3e37e3a3">count</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a06e36a368cbf554fc817b0cb3e37e3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of occurrences of a key in a JSON object  <a href="classbasic__json.html#a06e36a368cbf554fc817b0cb3e37e3a3">More...</a><br /></td></tr>
<tr class="separator:a06e36a368cbf554fc817b0cb3e37e3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3815a53b61818c87cf677f4a1ea5b7e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3815a53b61818c87cf677f4a1ea5b7e8">contains</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:a3815a53b61818c87cf677f4a1ea5b7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object  <a href="classbasic__json.html#a3815a53b61818c87cf677f4a1ea5b7e8">More...</a><br /></td></tr>
<tr class="separator:a3815a53b61818c87cf677f4a1ea5b7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dbcc61c27689659fa1d94a19bd2560"><td class="memTemplParams" colspan="2">template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a56dbcc61c27689659fa1d94a19bd2560"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a56dbcc61c27689659fa1d94a19bd2560">contains</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a56dbcc61c27689659fa1d94a19bd2560"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object  <a href="classbasic__json.html#a56dbcc61c27689659fa1d94a19bd2560">More...</a><br /></td></tr>
<tr class="separator:a56dbcc61c27689659fa1d94a19bd2560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7241e94ede5aacd7efca401cf0638a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0d7241e94ede5aacd7efca401cf0638a">contains</a> (const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>) const</td></tr>
<tr class="memdesc:a0d7241e94ede5aacd7efca401cf0638a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object given a JSON pointer  <a href="classbasic__json.html#a0d7241e94ede5aacd7efca401cf0638a">More...</a><br /></td></tr>
<tr class="separator:a0d7241e94ede5aacd7efca401cf0638a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Pointer functions</h2></td></tr>
<tr class="memitem:a2f0b9af87d5c9c8bed6dc0e165af3147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2f0b9af87d5c9c8bed6dc0e165af3147">operator[]</a> (const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>)</td></tr>
<tr class="memdesc:a2f0b9af87d5c9c8bed6dc0e165af3147"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="classbasic__json.html#a2f0b9af87d5c9c8bed6dc0e165af3147">More...</a><br /></td></tr>
<tr class="separator:a2f0b9af87d5c9c8bed6dc0e165af3147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1739e4b1516871a96aeb29a030632c"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3b1739e4b1516871a96aeb29a030632c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3b1739e4b1516871a96aeb29a030632c">JSON_HEDLEY_DEPRECATED_FOR</a> (3.11.0, <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">basic_json::json_pointer</a> <a class="el" href="_third_party_notices_8txt.html#a3d2bcfd013d8297d0df0a31cb92e058c">or</a> wpi::json_pointer&lt; <a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">basic_json::string_t</a> &gt;) <a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> operator[](const</td></tr>
<tr class="separator:a3b1739e4b1516871a96aeb29a030632c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba36b6659d266fd0299446a20b611d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9ba36b6659d266fd0299446a20b611d9">operator[]</a> (const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>) const</td></tr>
<tr class="memdesc:a9ba36b6659d266fd0299446a20b611d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="classbasic__json.html#a9ba36b6659d266fd0299446a20b611d9">More...</a><br /></td></tr>
<tr class="separator:a9ba36b6659d266fd0299446a20b611d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f5b3ce3be9ff197fdbf31db68c0c7f"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a82f5b3ce3be9ff197fdbf31db68c0c7f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a82f5b3ce3be9ff197fdbf31db68c0c7f">JSON_HEDLEY_DEPRECATED_FOR</a> (3.11.0, <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">basic_json::json_pointer</a> <a class="el" href="_third_party_notices_8txt.html#a3d2bcfd013d8297d0df0a31cb92e058c">or</a> wpi::json_pointer&lt; <a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">basic_json::string_t</a> &gt;) const _reference operator[](const</td></tr>
<tr class="memdesc:a82f5b3ce3be9ff197fdbf31db68c0c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="classbasic__json.html#a82f5b3ce3be9ff197fdbf31db68c0c7f">More...</a><br /></td></tr>
<tr class="separator:a82f5b3ce3be9ff197fdbf31db68c0c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbef1075e5e51e4c35df21f9c940772"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aabbef1075e5e51e4c35df21f9c940772"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aabbef1075e5e51e4c35df21f9c940772">JSON_HEDLEY_DEPRECATED_FOR</a> (3.11.0, <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">basic_json::json_pointer</a> <a class="el" href="_third_party_notices_8txt.html#a3d2bcfd013d8297d0df0a31cb92e058c">or</a> wpi::json_pointer&lt; <a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">basic_json::string_t</a> &gt;) <a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html#a603779687f401ad11de45f8397f92296">at</a>(const</td></tr>
<tr class="separator:aabbef1075e5e51e4c35df21f9c940772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d4becb69fb528514395b46d123b69a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac7d4becb69fb528514395b46d123b69a">at</a> (const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>) const</td></tr>
<tr class="memdesc:ac7d4becb69fb528514395b46d123b69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="classbasic__json.html#ac7d4becb69fb528514395b46d123b69a">More...</a><br /></td></tr>
<tr class="separator:ac7d4becb69fb528514395b46d123b69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Merge Patch functions</h2></td></tr>
<tr class="memitem:a1c7ab88eb6d043b434cd9e0b68ec7321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1c7ab88eb6d043b434cd9e0b68ec7321">merge_patch</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;apply_patch)</td></tr>
<tr class="memdesc:a1c7ab88eb6d043b434cd9e0b68ec7321"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a JSON Merge Patch  <a href="classbasic__json.html#a1c7ab88eb6d043b434cd9e0b68ec7321">More...</a><br /></td></tr>
<tr class="separator:a1c7ab88eb6d043b434cd9e0b68ec7321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType = std::vector&lt;std::uint8_t&gt;&gt;<br />
class basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;</div><p >namespace for Niels Lohmann </p>
<p >a class to store JSON values</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/nlohmann">https://github.com/nlohmann</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0</dd></dl>
<p>a class to store JSON values</p>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/">https://json.nlohmann.me/api/basic_json/</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a485873eed243b6ca7e30c96130a5ec2d" name="a485873eed243b6ca7e30c96130a5ec2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485873eed243b6ca7e30c96130a5ec2d">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::allocator_type =  AllocatorType&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the allocator type </p>

</div>
</div>
<a id="a7cf28eb944e7c06aa47f0bc3a9d6f454" name="a7cf28eb944e7c06aa47f0bc3a9d6f454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf28eb944e7c06aa47f0bc3a9d6f454">&#9670;&nbsp;</a></span>array_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::array_t =  ArrayType&lt;<a class="el" href="classbasic__json.html">basic_json</a>, AllocatorType&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/array_t/">https://json.nlohmann.me/api/basic_json/array_t/</a> </dd></dl>

</div>
</div>
<a id="a10e4e8a0166fd47c006b82b20b2dcd7f" name="a10e4e8a0166fd47c006b82b20b2dcd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e4e8a0166fd47c006b82b20b2dcd7f">&#9670;&nbsp;</a></span>binary_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary_t =  wpi::byte_container_with_subtype&lt;BinaryType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a packed binary type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary_t/">https://json.nlohmann.me/api/basic_json/binary_t/</a> </dd></dl>

</div>
</div>
<a id="af396ac808d774d4ea0db4c7da11ce569" name="af396ac808d774d4ea0db4c7da11ce569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af396ac808d774d4ea0db4c7da11ce569">&#9670;&nbsp;</a></span>boolean_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::boolean_t =  BooleanType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a boolean </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/boolean_t/">https://json.nlohmann.me/api/basic_json/boolean_t/</a> </dd></dl>

</div>
</div>
<a id="a2373759df24fffb094fd7789c726abe1" name="a2373759df24fffb094fd7789c726abe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2373759df24fffb094fd7789c726abe1">&#9670;&nbsp;</a></span>cbor_tag_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::cbor_tag_handler_t =  <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">detail::cbor_tag_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>how to treat CBOR tags </p>

</div>
</div>
<a id="a8f3470194c24d964e40d9be0b177cbc3" name="a8f3470194c24d964e40d9be0b177cbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3470194c24d964e40d9be0b177cbc3">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::const_iterator =  iter_impl&lt;const <a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a const iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container </p>

</div>
</div>
<a id="a28ac2566e6ab084c5c1e044d132aa4a3" name="a28ac2566e6ab084c5c1e044d132aa4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ac2566e6ab084c5c1e044d132aa4a3">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::const_pointer =  typename std::allocator_traits&lt;<a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a>&gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element const pointer </p>

</div>
</div>
<a id="ac9d32cf719260c22b33bab670cd5602b" name="ac9d32cf719260c22b33bab670cd5602b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d32cf719260c22b33bab670cd5602b">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::const_reference =  const <a class="el" href="classbasic__json.html#ad9e6b75c7cc0db798b91e52edca5f4ca">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element const reference </p>

</div>
</div>
<a id="a2aa7d4c7719ab82aa8c77a83642c843f" name="a2aa7d4c7719ab82aa8c77a83642c843f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa7d4c7719ab82aa8c77a83642c843f">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::const_reverse_iterator =  json_reverse_iterator&lt;typename <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">basic_json::const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a const reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container </p>

</div>
</div>
<a id="af2fea7b2039e4308b8e8c22a0dd5b570" name="af2fea7b2039e4308b8e8c22a0dd5b570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fea7b2039e4308b8e8c22a0dd5b570">&#9670;&nbsp;</a></span>default_object_comparator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::default_object_comparator_t =  std::less&lt;StringType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default object key comparator type The actual object key comparator type (<a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a>) may be different. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/default_object_comparator_t/">https://json.nlohmann.me/api/basic_json/default_object_comparator_t/</a> </dd></dl>

</div>
</div>
<a id="a2fe32d636c1b78861884dde9716b22b6" name="a2fe32d636c1b78861884dde9716b22b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe32d636c1b78861884dde9716b22b6">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::difference_type =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type to represent differences between iterators </p>

</div>
</div>
<a id="abbc0836764d6ba2580ee0c775ceeeab7" name="abbc0836764d6ba2580ee0c775ceeeab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc0836764d6ba2580ee0c775ceeeab7">&#9670;&nbsp;</a></span>error_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::error_handler_t =  <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">detail::error_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>how to treat decoding errors </p>

</div>
</div>
<a id="ab671bd0e5eef59e58d362e6cd8937633" name="ab671bd0e5eef59e58d362e6cd8937633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab671bd0e5eef59e58d362e6cd8937633">&#9670;&nbsp;</a></span>exception</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::exception =  <a class="el" href="classdetail_1_1exception.html">detail::exception</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2063ed828cd027216c549ac48527a562" name="a2063ed828cd027216c549ac48527a562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2063ed828cd027216c549ac48527a562">&#9670;&nbsp;</a></span>initializer_list_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::initializer_list_t =  std::initializer_list&lt;<a class="el" href="classdetail_1_1json__ref.html">detail::json_ref</a>&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper type for initializer lists of <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> values </p>

</div>
</div>
<a id="a0bcf8e1a03522bf1ea9bb6fb49251dab" name="a0bcf8e1a03522bf1ea9bb6fb49251dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcf8e1a03522bf1ea9bb6fb49251dab">&#9670;&nbsp;</a></span>input_format_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::input_format_t =  <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">detail::input_format_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dbe40f1942d8e38ab2effc7988b05ea" name="a9dbe40f1942d8e38ab2effc7988b05ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbe40f1942d8e38ab2effc7988b05ea">&#9670;&nbsp;</a></span>invalid_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::invalid_iterator =  <a class="el" href="classdetail_1_1invalid__iterator.html">detail::invalid_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2935c91b82c8e586b1dd68ad665075a6" name="a2935c91b82c8e586b1dd68ad665075a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2935c91b82c8e586b1dd68ad665075a6">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::iterator =  iter_impl&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container </p>

</div>
</div>
<a id="a5def9176cd6361a5b210a6c1a9396c28" name="a5def9176cd6361a5b210a6c1a9396c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5def9176cd6361a5b210a6c1a9396c28">&#9670;&nbsp;</a></span>json_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classjson__pointer.html">::json_pointer</a> =  ::wpi::json_pointer&lt;StringType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JSON Pointer, see wpi::json_pointer. </p>

</div>
</div>
<a id="a0c291e7719ceccef199189e5ee4ecd4f" name="a0c291e7719ceccef199189e5ee4ecd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c291e7719ceccef199189e5ee4ecd4f">&#9670;&nbsp;</a></span>json_sax_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::json_sax_t =  <a class="el" href="structjson__sax.html">json_sax</a>&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SAX interface type, see wpi::json_sax. </p>

</div>
</div>
<a id="a5e8738738b9e5c4cdc6519e3799de38a" name="a5e8738738b9e5c4cdc6519e3799de38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8738738b9e5c4cdc6519e3799de38a">&#9670;&nbsp;</a></span>json_serializer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename SFINAE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::json_serializer =  JSONSerializer&lt;T, SFINAE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fd24dfabbdd1dc35513c82244633ca4" name="a1fd24dfabbdd1dc35513c82244633ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd24dfabbdd1dc35513c82244633ca4">&#9670;&nbsp;</a></span>number_float_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::number_float_t =  NumberFloatType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (floating-point) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_float_t/">https://json.nlohmann.me/api/basic_json/number_float_t/</a> </dd></dl>

</div>
</div>
<a id="a8b702448867b892700c768db4208a670" name="a8b702448867b892700c768db4208a670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b702448867b892700c768db4208a670">&#9670;&nbsp;</a></span>number_integer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::number_integer_t =  NumberIntegerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (integer) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_integer_t/">https://json.nlohmann.me/api/basic_json/number_integer_t/</a> </dd></dl>

</div>
</div>
<a id="aebb9c6a13e947a86e2a13fbe6ebd77f4" name="aebb9c6a13e947a86e2a13fbe6ebd77f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb9c6a13e947a86e2a13fbe6ebd77f4">&#9670;&nbsp;</a></span>number_unsigned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::number_unsigned_t =  NumberUnsignedType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (unsigned) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_unsigned_t/">https://json.nlohmann.me/api/basic_json/number_unsigned_t/</a> </dd></dl>

</div>
</div>
<a id="a7866de66dd6c55590efa7cf0ef79e74f" name="a7866de66dd6c55590efa7cf0ef79e74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7866de66dd6c55590efa7cf0ef79e74f">&#9670;&nbsp;</a></span>object_comparator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::object_comparator_t =  <a class="el" href="namespacedetail.html#acf3e5af512080ec5b71496dde9e0651c">detail::actual_object_comparator_t</a>&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>object key comparator type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object_comparator_t/">https://json.nlohmann.me/api/basic_json/object_comparator_t/</a> </dd></dl>

</div>
</div>
<a id="a770279b71f788fe3f76411eedf5b1956" name="a770279b71f788fe3f76411eedf5b1956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770279b71f788fe3f76411eedf5b1956">&#9670;&nbsp;</a></span>object_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::object_t =  ObjectType&lt;StringType, <a class="el" href="classbasic__json.html">basic_json</a>, <a class="el" href="classbasic__json.html#af2fea7b2039e4308b8e8c22a0dd5b570">default_object_comparator_t</a>, AllocatorType&lt;std::pair&lt;const StringType, <a class="el" href="classbasic__json.html">basic_json</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object_t/">https://json.nlohmann.me/api/basic_json/object_t/</a> </dd></dl>

</div>
</div>
<a id="aab2ef54e2baf390523dd6a5bc4ccccef" name="aab2ef54e2baf390523dd6a5bc4ccccef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2ef54e2baf390523dd6a5bc4ccccef">&#9670;&nbsp;</a></span>other_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::other_error =  <a class="el" href="classdetail_1_1other__error.html">detail::other_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a144d3cb5914a0a12c2f5d2b982a2214a" name="a144d3cb5914a0a12c2f5d2b982a2214a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144d3cb5914a0a12c2f5d2b982a2214a">&#9670;&nbsp;</a></span>out_of_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::out_of_range =  <a class="el" href="classdetail_1_1out__of__range.html">detail::out_of_range</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0da064d46469bb762afcecd1c361f1a" name="ab0da064d46469bb762afcecd1c361f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0da064d46469bb762afcecd1c361f1a">&#9670;&nbsp;</a></span>parse_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::parse_error =  <a class="el" href="classdetail_1_1parse__error.html">detail::parse_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfe811a234bbc90f4a0d3c6488272186" name="adfe811a234bbc90f4a0d3c6488272186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe811a234bbc90f4a0d3c6488272186">&#9670;&nbsp;</a></span>parse_event_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::parse_event_t =  <a class="el" href="namespacedetail.html#a47b1bb0bbd3596589ed9187059c312ef">detail::parse_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parser event types </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/parse_event_t/">https://json.nlohmann.me/api/basic_json/parse_event_t/</a> </dd></dl>

</div>
</div>
<a id="a144c201819ed5c9d9f58b59eb64fb454" name="a144c201819ed5c9d9f58b59eb64fb454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144c201819ed5c9d9f58b59eb64fb454">&#9670;&nbsp;</a></span>parser_callback_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::parser_callback_t =  <a class="el" href="namespacedetail.html#a20a6b9b232b9f47ce057fe5cc5bbf511">detail::parser_callback_t</a>&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>per-element parser callback type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/parser_callback_t/">https://json.nlohmann.me/api/basic_json/parser_callback_t/</a> </dd></dl>

</div>
</div>
<a id="ac02a5d1bf4e9cd1bdec90e97f4ea6f95" name="ac02a5d1bf4e9cd1bdec90e97f4ea6f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02a5d1bf4e9cd1bdec90e97f4ea6f95">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::pointer =  typename std::allocator_traits&lt;<a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a>&gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element pointer </p>

</div>
</div>
<a id="aa95f366d506aca733799e4c310927b5d" name="aa95f366d506aca733799e4c310927b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95f366d506aca733799e4c310927b5d">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::reference =  <a class="el" href="classbasic__json.html#ad9e6b75c7cc0db798b91e52edca5f4ca">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element reference </p>

</div>
</div>
<a id="ac639cd1b4238d158286e7e21b5829709" name="ac639cd1b4238d158286e7e21b5829709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac639cd1b4238d158286e7e21b5829709">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::reverse_iterator =  json_reverse_iterator&lt;typename <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">basic_json::iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container </p>

</div>
</div>
<a id="a8224cb1d9448be74cc62b8c139547ef1" name="a8224cb1d9448be74cc62b8c139547ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8224cb1d9448be74cc62b8c139547ef1">&#9670;&nbsp;</a></span>serializer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::serializer =  ::wpi::detail::serializer&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a883ac4726a370dbf98474944ec0a0acc" name="a883ac4726a370dbf98474944ec0a0acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883ac4726a370dbf98474944ec0a0acc">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::size_type =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type to represent container sizes </p>

</div>
</div>
<a id="a807932caebf0d62abc8642b9d1a2e5ef" name="a807932caebf0d62abc8642b9d1a2e5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807932caebf0d62abc8642b9d1a2e5ef">&#9670;&nbsp;</a></span>string_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::string_t =  StringType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/string_t/">https://json.nlohmann.me/api/basic_json/string_t/</a> </dd></dl>

</div>
</div>
<a id="a14db56e21a2c72186979c6f6f0469557" name="a14db56e21a2c72186979c6f6f0469557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14db56e21a2c72186979c6f6f0469557">&#9670;&nbsp;</a></span>type_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::type_error =  <a class="el" href="classdetail_1_1type__error.html">detail::type_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea7fcb38964d53d35e84a80b8b1e8d11" name="aea7fcb38964d53d35e84a80b8b1e8d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7fcb38964d53d35e84a80b8b1e8d11">&#9670;&nbsp;</a></span>value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value_t =  <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9e6b75c7cc0db798b91e52edca5f4ca" name="ad9e6b75c7cc0db798b91e52edca5f4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e6b75c7cc0db798b91e52edca5f4ca">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value_type =  <a class="el" href="classbasic__json.html">basic_json</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of elements in a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aee75ecbdc67fc5faa1228c949c59ff27" name="aee75ecbdc67fc5faa1228c949c59ff27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee75ecbdc67fc5faa1228c949c59ff27">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an empty value with a given type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="ac6f1bad4745ddb574540f71cdbcd532f" name="ac6f1bad4745ddb574540f71cdbcd532f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f1bad4745ddb574540f71cdbcd532f">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a null object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="a9b1f9ac7c7ebcff72d00869e974a6249" name="a9b1f9ac7c7ebcff72d00869e974a6249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1f9ac7c7ebcff72d00869e974a6249">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CompatibleType , typename U  = detail::uncvref_t&lt;CompatibleType&gt;, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; !<a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; U &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;<a class="el" href="structdetail_1_1is__compatible__type.html">detail::is_compatible_type</a>&lt; basic_json_t, U &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">CompatibleType &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from compatible types </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="a94560a1edd72d60310c54c9b2d9f1ad2" name="a94560a1edd72d60310c54c9b2d9f1ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94560a1edd72d60310c54c9b2d9f1ad2">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;!std::is_same&lt; <a class="el" href="classbasic__json.html">basic_json</a>, BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an existing one </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="aec3d71dec8062753efb67860b7cca1a1" name="aec3d71dec8062753efb67860b7cca1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3d71dec8062753efb67860b7cca1a1">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>type_deduction</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>manual_type</em> = <code><a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a container (array or object) from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="ad382c9c9e03c410004150c9d6b9f0bd9" name="ad382c9c9e03c410004150c9d6b9f0bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad382c9c9e03c410004150c9d6b9f0bd9">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct an array with count copies of given value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="a12f2c1a11dd6e84196132ea77a99572a" name="a12f2c1a11dd6e84196132ea77a99572a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f2c1a11dd6e84196132ea77a99572a">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIT , typename std::enable_if&lt; std::is_same&lt; InputIT, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; InputIT, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">InputIT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct a JSON container given an iterator range </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="a33adf04c1d841c42c0eeaf05252aedc3" name="a33adf04c1d841c42c0eeaf05252aedc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33adf04c1d841c42c0eeaf05252aedc3">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename JsonRef , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1conjunction.html">detail::conjunction</a>&lt; <a class="el" href="structdetail_1_1is__json__ref.html">detail::is_json_ref</a>&lt; JsonRef &gt;, std::is_same&lt; typename JsonRef::value_type, <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const JsonRef &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac62e476c88b91f1f4329bb4901cafc4c" name="ac62e476c88b91f1f4329bb4901cafc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62e476c88b91f1f4329bb4901cafc4c">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="aa269ba998ca2e15b2f596a8c074d125f" name="aa269ba998ca2e15b2f596a8c074d125f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa269ba998ca2e15b2f596a8c074d125f">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="ad0209408ec1ed66ea5f89a7d72e57e43" name="ad0209408ec1ed66ea5f89a7d72e57e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0209408ec1ed66ea5f89a7d72e57e43">&#9670;&nbsp;</a></span>~basic_json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::~<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/~basic_json/">https://json.nlohmann.me/api/basic_json/~basic_json/</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a08a68350d457af1f6ea7f27b6e0a5baf" name="a08a68350d457af1f6ea7f27b6e0a5baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a68350d457af1f6ea7f27b6e0a5baf">&#9670;&nbsp;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create an array from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/array/">https://json.nlohmann.me/api/basic_json/array/</a> </dd></dl>

</div>
</div>
<a id="ac7d4becb69fb528514395b46d123b69a" name="ac7d4becb69fb528514395b46d123b69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d4becb69fb528514395b46d123b69a">&#9670;&nbsp;</a></span>at() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="aedf1894e1b70a4caebd95adec60e845a" name="aedf1894e1b70a4caebd95adec60e845a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf1894e1b70a4caebd95adec60e845a">&#9670;&nbsp;</a></span>at() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="afc32b953a4e343dc7f8ab3465743f399" name="afc32b953a4e343dc7f8ab3465743f399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc32b953a4e343dc7f8ab3465743f399">&#9670;&nbsp;</a></span>at() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="afc69e86b65aa8b571ccad9d581ca5a2b" name="afc69e86b65aa8b571ccad9d581ca5a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc69e86b65aa8b571ccad9d581ca5a2b">&#9670;&nbsp;</a></span>at() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="aee87279fb115f6d57967e6e8f5542faa" name="aee87279fb115f6d57967e6e8f5542faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee87279fb115f6d57967e6e8f5542faa">&#9670;&nbsp;</a></span>at() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="a603779687f401ad11de45f8397f92296" name="a603779687f401ad11de45f8397f92296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603779687f401ad11de45f8397f92296">&#9670;&nbsp;</a></span>at() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="a98e6b7245d17021327eb3962d73ccc54" name="a98e6b7245d17021327eb3962d73ccc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e6b7245d17021327eb3962d73ccc54">&#9670;&nbsp;</a></span>at() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="adafea743a0a74f86433b8b7cc5bb24bf" name="adafea743a0a74f86433b8b7cc5bb24bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adafea743a0a74f86433b8b7cc5bb24bf">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/back/">https://json.nlohmann.me/api/basic_json/back/</a> </dd></dl>

</div>
</div>
<a id="a1bf48c36e00720e01f8f6bbd3df0bf5b" name="a1bf48c36e00720e01f8f6bbd3df0bf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf48c36e00720e01f8f6bbd3df0bf5b">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/back/">https://json.nlohmann.me/api/basic_json/back/</a> </dd></dl>

</div>
</div>
<a id="a8d25b7a4a6f6ee355193ee6b461ab3bd" name="a8d25b7a4a6f6ee355193ee6b461ab3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d25b7a4a6f6ee355193ee6b461ab3bd">&#9670;&nbsp;</a></span>binary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

</div>
</div>
<a id="a9a92f5028b858b39e0c49c722ba09793" name="a9a92f5028b858b39e0c49c722ba09793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a92f5028b858b39e0c49c722ba09793">&#9670;&nbsp;</a></span>binary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename binary_t::subtype_type&#160;</td>
          <td class="paramname"><em>subtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (with subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

</div>
</div>
<a id="a0767ec4050ecfb4e4852db24cc939b2b" name="a0767ec4050ecfb4e4852db24cc939b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0767ec4050ecfb4e4852db24cc939b2b">&#9670;&nbsp;</a></span>binary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

</div>
</div>
<a id="a6ad9ba515c5f51d9c5609583e3d0ada0" name="a6ad9ba515c5f51d9c5609583e3d0ada0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad9ba515c5f51d9c5609583e3d0ada0">&#9670;&nbsp;</a></span>binary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename binary_t::subtype_type&#160;</td>
          <td class="paramname"><em>subtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (with subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

</div>
</div>
<a id="a0d7241e94ede5aacd7efca401cf0638a" name="a0d7241e94ede5aacd7efca401cf0638a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7241e94ede5aacd7efca401cf0638a">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object given a JSON pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

</div>
</div>
<a id="a3815a53b61818c87cf677f4a1ea5b7e8" name="a3815a53b61818c87cf677f4a1ea5b7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3815a53b61818c87cf677f4a1ea5b7e8">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

</div>
</div>
<a id="a56dbcc61c27689659fa1d94a19bd2560" name="a56dbcc61c27689659fa1d94a19bd2560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dbcc61c27689659fa1d94a19bd2560">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

</div>
</div>
<a id="ac122e03d4d28d6a03c01abaa7229d4c7" name="ac122e03d4d28d6a03c01abaa7229d4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac122e03d4d28d6a03c01abaa7229d4c7">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of occurrences of a key in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/count/">https://json.nlohmann.me/api/basic_json/count/</a> </dd></dl>

</div>
</div>
<a id="a06e36a368cbf554fc817b0cb3e37e3a3" name="a06e36a368cbf554fc817b0cb3e37e3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e36a368cbf554fc817b0cb3e37e3a3">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of occurrences of a key in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/count/">https://json.nlohmann.me/api/basic_json/count/</a> </dd></dl>

</div>
</div>
<a id="aff2204c04cd35b2cef35f44b2b93ffc7" name="aff2204c04cd35b2cef35f44b2b93ffc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2204c04cd35b2cef35f44b2b93ffc7">&#9670;&nbsp;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a diff as a JSON patch </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/diff/">https://json.nlohmann.me/api/basic_json/diff/</a> </dd></dl>

</div>
</div>
<a id="ac38b5f79c16205efb771e99be206b345" name="ac38b5f79c16205efb771e99be206b345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38b5f79c16205efb771e99be206b345">&#9670;&nbsp;</a></span>dump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ensure_ascii</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a>&#160;</td>
          <td class="paramname"><em>error_handler</em> = <code>error_handler_t::strict</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serialization </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/dump/">https://json.nlohmann.me/api/basic_json/dump/</a> </dd></dl>

</div>
</div>
<a id="a24efea87e4dfe02fe67216e3c130dd76" name="a24efea87e4dfe02fe67216e3c130dd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24efea87e4dfe02fe67216e3c130dd76">&#9670;&nbsp;</a></span>dump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ensure_ascii</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a>&#160;</td>
          <td class="paramname"><em>error_handler</em> = <code>error_handler_t::strict</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e70795da670f11ad7925407d0a7d83c" name="a3e70795da670f11ad7925407d0a7d83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e70795da670f11ad7925407d0a7d83c">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>, bool &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object if key does not exist </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/emplace/">https://json.nlohmann.me/api/basic_json/emplace/</a> </dd></dl>

</div>
</div>
<a id="a7ad89dd8715111483428ecf8534b9393" name="a7ad89dd8715111483428ecf8534b9393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad89dd8715111483428ecf8534b9393">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/emplace_back/">https://json.nlohmann.me/api/basic_json/emplace_back/</a> </dd></dl>

</div>
</div>
<a id="a0e480e9d2391485c79747bb756628f61" name="a0e480e9d2391485c79747bb756628f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e480e9d2391485c79747bb756628f61">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON array given an index </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

</div>
</div>
<a id="a8d29d171d8941523a937bb6b5132b5a7" name="a8d29d171d8941523a937bb6b5132b5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d29d171d8941523a937bb6b5132b5a7">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON object given a key </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

</div>
</div>
<a id="a151124c5b91ecb1278c7e191053ce9ca" name="a151124c5b91ecb1278c7e191053ce9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151124c5b91ecb1278c7e191053ce9ca">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove elements given an iterator range </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

</div>
</div>
<a id="a7a5ed019983b582705ef5ee43d15ca24" name="a7a5ed019983b582705ef5ee43d15ca24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5ed019983b582705ef5ee43d15ca24">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element given an iterator </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

</div>
</div>
<a id="a3054e673f67fa325fbdcd0bf73d03c7b" name="a3054e673f67fa325fbdcd0bf73d03c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3054e673f67fa325fbdcd0bf73d03c7b">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON object given a key </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

</div>
</div>
<a id="a8ed11f83edce392fd94659b1102d078e" name="a8ed11f83edce392fd94659b1102d078e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed11f83edce392fd94659b1102d078e">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

</div>
</div>
<a id="a8d8085b05e9a2e6f187708bca5e22d04" name="a8d8085b05e9a2e6f187708bca5e22d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8085b05e9a2e6f187708bca5e22d04">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

</div>
</div>
<a id="a81e01eb7be2878873ba084c0a0b20442" name="a81e01eb7be2878873ba084c0a0b20442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e01eb7be2878873ba084c0a0b20442">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

</div>
</div>
<a id="a42890814a18f9c593f69218706113474" name="a42890814a18f9c593f69218706113474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42890814a18f9c593f69218706113474">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

</div>
</div>
<a id="affeac471308bec4cfe026258f746cfcc" name="affeac471308bec4cfe026258f746cfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affeac471308bec4cfe026258f746cfcc">&#9670;&nbsp;</a></span>from_bjdata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bjdata </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BJData format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bjdata/">https://json.nlohmann.me/api/basic_json/from_bjdata/</a> </dd></dl>

</div>
</div>
<a id="a94c00d3023a03b37d9a362cdf61c17c1" name="a94c00d3023a03b37d9a362cdf61c17c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c00d3023a03b37d9a362cdf61c17c1">&#9670;&nbsp;</a></span>from_bjdata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bjdata </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BJData format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bjdata/">https://json.nlohmann.me/api/basic_json/from_bjdata/</a> </dd></dl>

</div>
</div>
<a id="aa5d6a52ae542b7ffd137e87e72f9bcce" name="aa5d6a52ae542b7ffd137e87e72f9bcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d6a52ae542b7ffd137e87e72f9bcce">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a868a32e0da318e39872fb825b377bda6" name="a868a32e0da318e39872fb825b377bda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868a32e0da318e39872fb825b377bda6">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ac8b0effce93dad2e3eec9c1a7ed129" name="a5ac8b0effce93dad2e3eec9c1a7ed129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac8b0effce93dad2e3eec9c1a7ed129">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bson/">https://json.nlohmann.me/api/basic_json/from_bson/</a> </dd></dl>

</div>
</div>
<a id="a06c87b306915435958b5e584dfb80ce4" name="a06c87b306915435958b5e584dfb80ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c87b306915435958b5e584dfb80ce4">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bson/">https://json.nlohmann.me/api/basic_json/from_bson/</a> </dd></dl>

</div>
</div>
<a id="a0dcdc5f7b4a7ebf4b2a1a21710ad246d" name="a0dcdc5f7b4a7ebf4b2a1a21710ad246d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcdc5f7b4a7ebf4b2a1a21710ad246d">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adff52051e3e569f6f801b2d7b66124b1" name="adff52051e3e569f6f801b2d7b66124b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff52051e3e569f6f801b2d7b66124b1">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84e2d9cbd8a385017bb3d91c45a1753a" name="a84e2d9cbd8a385017bb3d91c45a1753a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e2d9cbd8a385017bb3d91c45a1753a">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in CBOR format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_cbor/">https://json.nlohmann.me/api/basic_json/from_cbor/</a> </dd></dl>

</div>
</div>
<a id="a93872bc620a9bbe028be81a3eaae21f3" name="a93872bc620a9bbe028be81a3eaae21f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93872bc620a9bbe028be81a3eaae21f3">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in CBOR format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_cbor/">https://json.nlohmann.me/api/basic_json/from_cbor/</a> </dd></dl>

</div>
</div>
<a id="ac347f43d4eb713aa711d6c8a5fca41cf" name="ac347f43d4eb713aa711d6c8a5fca41cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac347f43d4eb713aa711d6c8a5fca41cf">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a29d7be59d39991efb3a584cd2e6598" name="a2a29d7be59d39991efb3a584cd2e6598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a29d7be59d39991efb3a584cd2e6598">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96ba0ffab9429d589d658d3e053b8273" name="a96ba0ffab9429d589d658d3e053b8273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ba0ffab9429d589d658d3e053b8273">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in MessagePack format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_msgpack/">https://json.nlohmann.me/api/basic_json/from_msgpack/</a> </dd></dl>

</div>
</div>
<a id="a7f3794747f5b19e0504afa3585476e97" name="a7f3794747f5b19e0504afa3585476e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3794747f5b19e0504afa3585476e97">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in MessagePack format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_msgpack/">https://json.nlohmann.me/api/basic_json/from_msgpack/</a> </dd></dl>

</div>
</div>
<a id="a3d5a903e9aad342917fc3e98c070a0d7" name="a3d5a903e9aad342917fc3e98c070a0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5a903e9aad342917fc3e98c070a0d7">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99be0ee4212c46c20ee32d4a1a90cc6c" name="a99be0ee4212c46c20ee32d4a1a90cc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99be0ee4212c46c20ee32d4a1a90cc6c">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a662ee4905d8c2628b3018b378bbd4c9e" name="a662ee4905d8c2628b3018b378bbd4c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662ee4905d8c2628b3018b378bbd4c9e">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in UBJSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_ubjson/">https://json.nlohmann.me/api/basic_json/from_ubjson/</a> </dd></dl>

</div>
</div>
<a id="ad36123b583eaae095ee46413e4e380ef" name="ad36123b583eaae095ee46413e4e380ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36123b583eaae095ee46413e4e380ef">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in UBJSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_ubjson/">https://json.nlohmann.me/api/basic_json/from_ubjson/</a> </dd></dl>

</div>
</div>
<a id="a85577855985468abef750d5265e23c2a" name="a85577855985468abef750d5265e23c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85577855985468abef750d5265e23c2a">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the first element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/front/">https://json.nlohmann.me/api/basic_json/front/</a> </dd></dl>

</div>
</div>
<a id="ab11bff397526e8255d151066caeba48e" name="ab11bff397526e8255d151066caeba48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11bff397526e8255d151066caeba48e">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().template get_impl&lt;ValueType&gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt;4&gt; {}))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a (pointer) value (explicit) </p>
<p >Performs explicit type conversion between the JSON value and a compatible value if required.</p>
<ul>
<li>If the requested type is a pointer to the internally stored JSON value that pointer is returned. No copies are made.</li>
<li>If the requested type is the current <a class="el" href="classbasic__json.html">basic_json</a>, or a different <a class="el" href="classbasic__json.html">basic_json</a> convertible from the current <a class="el" href="classbasic__json.html">basic_json</a>.</li>
<li>Otherwise the value is converted by calling the <a class="el" href="classbasic__json.html#a5e8738738b9e5c4cdc6519e3799de38a">json_serializer&lt;ValueType&gt;</a> <code><a class="el" href="namespacefrc.html#a599251d0d1fde07a3f07f3ecf6d8e78d">from_json()</a></code> method.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueTypeCV</td><td>the provided value type </td></tr>
    <tr><td class="paramname">ValueType</td><td>the returned value type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the JSON value, converted to </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>if necessary</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">what</td><td><a class="el" href="classbasic__json.html#a5e8738738b9e5c4cdc6519e3799de38a">json_serializer&lt;ValueType&gt;</a> <code><a class="el" href="namespacefrc.html#a599251d0d1fde07a3f07f3ecf6d8e78d">from_json()</a></code> method throws if conversion is required</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

</div>
</div>
<a id="a35fa19a3f6193409abe4bd9014712105" name="a35fa19a3f6193409abe4bd9014712105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fa19a3f6193409abe4bd9014712105">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().template <a class="el" href="classbasic__json.html#a206a3748ff1fc676f64f753e203388dd">get_ptr</a>&lt;PointerType&gt;())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (explicit) </p>
<p >Explicit pointer access to the internally stored JSON value. No copies are made.</p>
<dl class="section warning"><dt>Warning</dt><dd>The pointer becomes invalid if the underlying JSON object changes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointerType</td><td>pointer type; must be a pointer to <a class="el" href="classbasic__json.html#a7cf28eb944e7c06aa47f0bc3a9d6f454">array_t</a>, <a class="el" href="classbasic__json.html#a770279b71f788fe3f76411eedf5b1956">object_t</a>, <a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a>, <a class="el" href="classbasic__json.html#af396ac808d774d4ea0db4c7da11ce569">boolean_t</a>, <a class="el" href="classbasic__json.html#a8b702448867b892700c768db4208a670">number_integer_t</a>, <a class="el" href="classbasic__json.html#aebb9c6a13e947a86e2a13fbe6ebd77f4">number_unsigned_t</a>, or <a class="el" href="classbasic__json.html#a1fd24dfabbdd1dc35513c82244633ca4">number_float_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the internally stored JSON value if the requested pointer type <em>PointerType</em> fits to the JSON value; <code>nullptr</code> otherwise</dd></dl>
<p>@complexity Constant.</p>
<p >@liveexample{The example below shows how pointers to internal values of a JSON value can be requested. Note that no type conversions are made and a <code>nullptr</code> is returned if the value and the requested pointer type does not match.,get__PointerType}</p>
<dl class="section see"><dt>See also</dt><dd>see <a class="el" href="classbasic__json.html#a206a3748ff1fc676f64f753e203388dd">get_ptr()</a> for explicit pointer-member access</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

</div>
</div>
<a id="a1aaddd9686fb1dd50203c2138858df7e" name="a1aaddd9686fb1dd50203c2138858df7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aaddd9686fb1dd50203c2138858df7e">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the allocator associated with the container </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_allocator/">https://json.nlohmann.me/api/basic_json/get_allocator/</a> </dd></dl>

</div>
</div>
<a id="aa4401911681258520903f3c374a9e994" name="aa4401911681258520903f3c374a9e994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4401911681258520903f3c374a9e994">&#9670;&nbsp;</a></span>get_binary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a10e4e8a0166fd47c006b82b20b2dcd7f">binary_t</a> &amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a binary value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_binary/">https://json.nlohmann.me/api/basic_json/get_binary/</a> </dd></dl>

</div>
</div>
<a id="a44b4244ff0e901156adfad7b027232de" name="a44b4244ff0e901156adfad7b027232de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b4244ff0e901156adfad7b027232de">&#9670;&nbsp;</a></span>get_binary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbasic__json.html#a10e4e8a0166fd47c006b82b20b2dcd7f">binary_t</a> &amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a binary value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_binary/">https://json.nlohmann.me/api/basic_json/get_binary/</a> </dd></dl>

</div>
</div>
<a id="a2055fcc0c999d3cb4c211f258695faff" name="a2055fcc0c999d3cb4c211f258695faff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2055fcc0c999d3cb4c211f258695faff">&#9670;&nbsp;</a></span>get_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_const&lt; typename std::remove_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ptr/">https://json.nlohmann.me/api/basic_json/get_ptr/</a> </dd></dl>

</div>
</div>
<a id="a206a3748ff1fc676f64f753e203388dd" name="a206a3748ff1fc676f64f753e203388dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206a3748ff1fc676f64f753e203388dd">&#9670;&nbsp;</a></span>get_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ptr/">https://json.nlohmann.me/api/basic_json/get_ptr/</a> </dd></dl>

</div>
</div>
<a id="a7bfdaa5014da75e18dd07cc76e53b237" name="a7bfdaa5014da75e18dd07cc76e53b237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfdaa5014da75e18dd07cc76e53b237">&#9670;&nbsp;</a></span>get_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReferenceType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ref/">https://json.nlohmann.me/api/basic_json/get_ref/</a> </dd></dl>

</div>
</div>
<a id="a42f1f9cf90ed5254e38e6b587fce237d" name="a42f1f9cf90ed5254e38e6b587fce237d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f1f9cf90ed5254e38e6b587fce237d">&#9670;&nbsp;</a></span>get_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_const&lt; typename std::remove_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReferenceType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ref/">https://json.nlohmann.me/api/basic_json/get_ref/</a> </dd></dl>

</div>
</div>
<a id="ac6a78b37dee5a709f610375403597bba" name="ac6a78b37dee5a709f610375403597bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a78b37dee5a709f610375403597bba">&#9670;&nbsp;</a></span>get_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename Array  = T (&amp;)[N], <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1has__from__json.html">detail::has_from_json</a>&lt; basic_json_t, Array &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>v</em>[N]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e0131c192963ed4d1148805120aa319" name="a9e0131c192963ed4d1148805120aa319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0131c192963ed4d1148805120aa319">&#9670;&nbsp;</a></span>get_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType &amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a251b2b7f275328615aed5a0f827e7710" name="a251b2b7f275328615aed5a0f827e7710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251b2b7f275328615aed5a0f827e7710">&#9670;&nbsp;</a></span>get_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; !<a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;<a class="el" href="structdetail_1_1has__from__json.html">detail::has_from_json</a>&lt; basic_json_t, ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType &amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a value (explicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_to/">https://json.nlohmann.me/api/basic_json/get_to/</a> </dd></dl>

</div>
</div>
<a id="a797b7b5589862535c88b9604c88d8d3e" name="a797b7b5589862535c88b9604c88d8d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797b7b5589862535c88b9604c88d8d3e">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts range of elements into object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="a5cd6ab85d95fa08d0fbce5f957834f28" name="a5cd6ab85d95fa08d0fbce5f957834f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd6ab85d95fa08d0fbce5f957834f28">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="a4467ec0c7679150140f9d2f85e95bf4b" name="a4467ec0c7679150140f9d2f85e95bf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4467ec0c7679150140f9d2f85e95bf4b">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="af30d7fc224999adeaa9e4dcd81db0f05" name="af30d7fc224999adeaa9e4dcd81db0f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30d7fc224999adeaa9e4dcd81db0f05">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts range of elements into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="a3b25eeb503c9f30322b966af0451da38" name="a3b25eeb503c9f30322b966af0451da38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b25eeb503c9f30322b966af0451da38">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts elements from initializer list into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="a1d7b302f4e6249b8b28dcfbebd934600" name="a1d7b302f4e6249b8b28dcfbebd934600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7b302f4e6249b8b28dcfbebd934600">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts copies of element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="a6940b08bda32ce195a9e4508b8aa1126" name="a6940b08bda32ce195a9e4508b8aa1126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6940b08bda32ce195a9e4508b8aa1126">&#9670;&nbsp;</a></span>insert_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for insertion of an iterator. </p>
<dl class="section note"><dt>Note</dt><dd>: This uses std::distance to support GCC 4.8, see <a href="https://github.com/nlohmann/json/pull/1257">https://github.com/nlohmann/json/pull/1257</a> </dd></dl>

</div>
</div>
<a id="a89ea48a4e802ef81783c0c7ce89aa7bb" name="a89ea48a4e802ef81783c0c7ce89aa7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ea48a4e802ef81783c0c7ce89aa7bb">&#9670;&nbsp;</a></span>is_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_array/">https://json.nlohmann.me/api/basic_json/is_array/</a> </dd></dl>

</div>
</div>
<a id="aa25e81e71e2a263c0431f02f3245a8aa" name="aa25e81e71e2a263c0431f02f3245a8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25e81e71e2a263c0431f02f3245a8aa">&#9670;&nbsp;</a></span>is_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a binary array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_binary/">https://json.nlohmann.me/api/basic_json/is_binary/</a> </dd></dl>

</div>
</div>
<a id="a814771ab0add0def16119c157b44003a" name="a814771ab0add0def16119c157b44003a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814771ab0add0def16119c157b44003a">&#9670;&nbsp;</a></span>is_boolean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_boolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a boolean </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_boolean/">https://json.nlohmann.me/api/basic_json/is_boolean/</a> </dd></dl>

</div>
</div>
<a id="abcc7082bb9fa07704c659f6be7c41bc9" name="abcc7082bb9fa07704c659f6be7c41bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc7082bb9fa07704c659f6be7c41bc9">&#9670;&nbsp;</a></span>is_discarded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_discarded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is discarded </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_discarded/">https://json.nlohmann.me/api/basic_json/is_discarded/</a> </dd></dl>

</div>
</div>
<a id="a6ed948b2c2e71ce5f5c03b5eeb575df4" name="a6ed948b2c2e71ce5f5c03b5eeb575df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed948b2c2e71ce5f5c03b5eeb575df4">&#9670;&nbsp;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is null </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_null/">https://json.nlohmann.me/api/basic_json/is_null/</a> </dd></dl>

</div>
</div>
<a id="ab84294fe5d1a2822e2f67685f6e8c735" name="ab84294fe5d1a2822e2f67685f6e8c735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84294fe5d1a2822e2f67685f6e8c735">&#9670;&nbsp;</a></span>is_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number/">https://json.nlohmann.me/api/basic_json/is_number/</a> </dd></dl>

</div>
</div>
<a id="aa8c885a9182fd22b05826ab2a9548f60" name="aa8c885a9182fd22b05826ab2a9548f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c885a9182fd22b05826ab2a9548f60">&#9670;&nbsp;</a></span>is_number_float()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a floating-point number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_float/">https://json.nlohmann.me/api/basic_json/is_number_float/</a> </dd></dl>

</div>
</div>
<a id="ad14438fe7c1f5a2f750eb56b8e73e538" name="ad14438fe7c1f5a2f750eb56b8e73e538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14438fe7c1f5a2f750eb56b8e73e538">&#9670;&nbsp;</a></span>is_number_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number_integer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an integer number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_integer/">https://json.nlohmann.me/api/basic_json/is_number_integer/</a> </dd></dl>

</div>
</div>
<a id="aa5744d3f2404f2376ab0dbe531e4d3bc" name="aa5744d3f2404f2376ab0dbe531e4d3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5744d3f2404f2376ab0dbe531e4d3bc">&#9670;&nbsp;</a></span>is_number_unsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number_unsigned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an unsigned integer number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_unsigned/">https://json.nlohmann.me/api/basic_json/is_number_unsigned/</a> </dd></dl>

</div>
</div>
<a id="af758a912346776b086abb82487b1d73b" name="af758a912346776b086abb82487b1d73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af758a912346776b086abb82487b1d73b">&#9670;&nbsp;</a></span>is_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_object/">https://json.nlohmann.me/api/basic_json/is_object/</a> </dd></dl>

</div>
</div>
<a id="a7fa8bc506b1519193a7bbc09f8a0f095" name="a7fa8bc506b1519193a7bbc09f8a0f095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa8bc506b1519193a7bbc09f8a0f095">&#9670;&nbsp;</a></span>is_primitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether type is primitive </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_primitive/">https://json.nlohmann.me/api/basic_json/is_primitive/</a> </dd></dl>

</div>
</div>
<a id="a3d4378552d27c9f15e4cb4ff4c075c94" name="a3d4378552d27c9f15e4cb4ff4c075c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4378552d27c9f15e4cb4ff4c075c94">&#9670;&nbsp;</a></span>is_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_string/">https://json.nlohmann.me/api/basic_json/is_string/</a> </dd></dl>

</div>
</div>
<a id="aded85ec1014821c21b8a47bc816a6917" name="aded85ec1014821c21b8a47bc816a6917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded85ec1014821c21b8a47bc816a6917">&#9670;&nbsp;</a></span>is_structured()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_structured </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether type is structured </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_structured/">https://json.nlohmann.me/api/basic_json/is_structured/</a> </dd></dl>

</div>
</div>
<a id="a82f5b3ce3be9ff197fdbf31db68c0c7f" name="a82f5b3ce3be9ff197fdbf31db68c0c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f5b3ce3be9ff197fdbf31db68c0c7f">&#9670;&nbsp;</a></span>JSON_HEDLEY_DEPRECATED_FOR() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::JSON_HEDLEY_DEPRECATED_FOR </td>
          <td>(</td>
          <td class="paramtype">3.11.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classjson__pointer.html">::json_pointer</a> <a class="el" href="_third_party_notices_8txt.html#a3d2bcfd013d8297d0df0a31cb92e058c">or</a> wpi::json_pointer&lt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">::string_t</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="aabbef1075e5e51e4c35df21f9c940772" name="aabbef1075e5e51e4c35df21f9c940772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbef1075e5e51e4c35df21f9c940772">&#9670;&nbsp;</a></span>JSON_HEDLEY_DEPRECATED_FOR() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::JSON_HEDLEY_DEPRECATED_FOR </td>
          <td>(</td>
          <td class="paramtype">3.11.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classjson__pointer.html">::json_pointer</a> <a class="el" href="_third_party_notices_8txt.html#a3d2bcfd013d8297d0df0a31cb92e058c">or</a> wpi::json_pointer&lt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">::string_t</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b1739e4b1516871a96aeb29a030632c" name="a3b1739e4b1516871a96aeb29a030632c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1739e4b1516871a96aeb29a030632c">&#9670;&nbsp;</a></span>JSON_HEDLEY_DEPRECATED_FOR() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::JSON_HEDLEY_DEPRECATED_FOR </td>
          <td>(</td>
          <td class="paramtype">3.11.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classjson__pointer.html">::json_pointer</a> <a class="el" href="_third_party_notices_8txt.html#a3d2bcfd013d8297d0df0a31cb92e058c">or</a> wpi::json_pointer&lt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">::string_t</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6626fcc2720b8cda13c3789a9613bef" name="ac6626fcc2720b8cda13c3789a9613bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6626fcc2720b8cda13c3789a9613bef">&#9670;&nbsp;</a></span>JSON_HEDLEY_DEPRECATED_FOR() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class BasicJsonType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::JSON_HEDLEY_DEPRECATED_FOR </td>
          <td>(</td>
          <td class="paramtype">3.11.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classjson__pointer.html">::json_pointer</a> <a class="el" href="_third_party_notices_8txt.html#a3d2bcfd013d8297d0df0a31cb92e058c">or</a> wpi::json_pointer&lt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">::string_t</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the first element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/front/">https://json.nlohmann.me/api/basic_json/front/</a> </dd></dl>

</div>
</div>
<a id="a1c7ab88eb6d043b434cd9e0b68ec7321" name="a1c7ab88eb6d043b434cd9e0b68ec7321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7ab88eb6d043b434cd9e0b68ec7321">&#9670;&nbsp;</a></span>merge_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::merge_patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>apply_patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies a JSON Merge Patch </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/merge_patch/">https://json.nlohmann.me/api/basic_json/merge_patch/</a> </dd></dl>

</div>
</div>
<a id="a08303da85f75965764bb0c8d8b79a449" name="a08303da85f75965764bb0c8d8b79a449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08303da85f75965764bb0c8d8b79a449">&#9670;&nbsp;</a></span>meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::meta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns version information on the library </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/meta/">https://json.nlohmann.me/api/basic_json/meta/</a> </dd></dl>

</div>
</div>
<a id="a10aa3ec9e58f6852709913408519c01c" name="a10aa3ec9e58f6852709913408519c01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aa3ec9e58f6852709913408519c01c">&#9670;&nbsp;</a></span>object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="hedley_8h.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create an object from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object/">https://json.nlohmann.me/api/basic_json/object/</a> </dd></dl>

</div>
</div>
<a id="ab025e8b5ac852c84758f92183b569b99" name="ab025e8b5ac852c84758f92183b569b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab025e8b5ac852c84758f92183b569b99">&#9670;&nbsp;</a></span>operator value_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type of the JSON value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_value_t/">https://json.nlohmann.me/api/basic_json/operator_value_t/</a> </dd></dl>

</div>
</div>
<a id="a31ccb49215a3dcac15438fb94485e86f" name="a31ccb49215a3dcac15438fb94485e86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ccb49215a3dcac15438fb94485e86f">&#9670;&nbsp;</a></span>operator ValueType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , typename std::enable_if&lt; <a class="el" href="structdetail_1_1conjunction.html">detail::conjunction</a>&lt; <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_pointer&lt; ValueType &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, std::nullptr_t &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, <a class="el" href="classdetail_1_1json__ref.html">detail::json_ref</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, typename string_t::value_type &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, std::initializer_list&lt; typename string_t::value_type &gt; &gt; &gt;, <a class="el" href="structdetail_1_1is__detected__lazy.html">detail::is_detected_lazy</a>&lt; <a class="el" href="namespacedetail.html#a34780011ee13a3ede041ddcee288f484">detail::get_template_function</a>, const basic_json_t &amp;, ValueType &gt; &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macro__scope_8h.html#aefed8cf27cadeea45f12c6f3db3ce774">JSON_EXPLICIT</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator ValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a value (implicit) </p>
<p >Implicit type conversion between the JSON value and a compatible value. The call is realized by calling <a class="el" href="classbasic__json.html#ab11bff397526e8255d151066caeba48e">get() const</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>non-pointer type compatible to the JSON value, for instance <code>int</code> for JSON integer numbers, <code>bool</code> for JSON booleans, or <code>std::vector</code> types for JSON arrays. The character type of <a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a> as well as an initializer list of this type is excluded to avoid ambiguities as these types implicitly convert to <code>std::string</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the JSON value, converted to type <em>ValueType</em> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">type_error.302</td><td>in case passed type <em>ValueType</em> is incompatible to the JSON value type (e.g., the JSON value is of type boolean, but a string is requested); see example below</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity Linear in the size of the JSON value.</p>
<p >@liveexample{The example below shows several conversions from JSON values to other types. There a few things to note: (1) Floating-point numbers can be converted to integers\, (2) A JSON array can be converted to a standard <code>std::vector&lt;short&gt;</code>\, (3) A JSON object can be converted to C++ associative containers such as <code>std::unordered_map&lt;std::string\, json&gt;</code>.,operator__ValueType}</p>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

</div>
</div>
<a id="a042aa42f535d1dbf2176d159fd3d96eb" name="a042aa42f535d1dbf2176d159fd3d96eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042aa42f535d1dbf2176d159fd3d96eb">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

</div>
</div>
<a id="afbbf3e602301f1b9fc81c445c8f3bd1a" name="afbbf3e602301f1b9fc81c445c8f3bd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbf3e602301f1b9fc81c445c8f3bd1a">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

</div>
</div>
<a id="a024a7d334069a60f8cb95c3f858fc9e6" name="a024a7d334069a60f8cb95c3f858fc9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024a7d334069a60f8cb95c3f858fc9e6">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

</div>
</div>
<a id="ae3350669b0628bf54a4771512a55f135" name="ae3350669b0628bf54a4771512a55f135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3350669b0628bf54a4771512a55f135">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

</div>
</div>
<a id="a8cb70d0ea0c23ac40f1f3b67d40c174f" name="a8cb70d0ea0c23ac40f1f3b67d40c174f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb70d0ea0c23ac40f1f3b67d40c174f">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a> &amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy assignment </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator=/">https://json.nlohmann.me/api/basic_json/operator=/</a> </dd></dl>

</div>
</div>
<a id="a2f0b9af87d5c9c8bed6dc0e165af3147" name="a2f0b9af87d5c9c8bed6dc0e165af3147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0b9af87d5c9c8bed6dc0e165af3147">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="a9ba36b6659d266fd0299446a20b611d9" name="a9ba36b6659d266fd0299446a20b611d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba36b6659d266fd0299446a20b611d9">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="af57b78559cad28275bc515bb2a072605" name="af57b78559cad28275bc515bb2a072605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57b78559cad28275bc515bb2a072605">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="a5a7e1bd642902ec90f118f00d48c024d" name="a5a7e1bd642902ec90f118f00d48c024d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7e1bd642902ec90f118f00d48c024d">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="afb04aaee2ee66a6c822aaad827123314" name="afb04aaee2ee66a6c822aaad827123314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb04aaee2ee66a6c822aaad827123314">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a>&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="aa3dfeae16fa9a8ec1390a27d6a4a58b3" name="aa3dfeae16fa9a8ec1390a27d6a4a58b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dfeae16fa9a8ec1390a27d6a4a58b3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="a61677841384622af7c3174f3f10df621" name="a61677841384622af7c3174f3f10df621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61677841384622af7c3174f3f10df621">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="abb748eeb63f40f12f81f9e9c5d53d127" name="abb748eeb63f40f12f81f9e9c5d53d127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb748eeb63f40f12f81f9e9c5d53d127">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19e43d3f7092719836ac3e8249044bb6" name="a19e43d3f7092719836ac3e8249044bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e43d3f7092719836ac3e8249044bb6">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a272177c4eb206c70f41e35146915b710" name="a272177c4eb206c70f41e35146915b710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272177c4eb206c70f41e35146915b710">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">typename object_t::key_type&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="a5a009b55b9dcdb30352f5f62537931b7" name="a5a009b55b9dcdb30352f5f62537931b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a009b55b9dcdb30352f5f62537931b7">&#9670;&nbsp;</a></span>patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>json_patch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies a JSON patch to a copy of the current object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/patch/">https://json.nlohmann.me/api/basic_json/patch/</a> </dd></dl>

</div>
</div>
<a id="a102e459f1d163cea963ed6fdda595cd3" name="a102e459f1d163cea963ed6fdda595cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102e459f1d163cea963ed6fdda595cd3">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

</div>
</div>
<a id="a4efb88d640b634b77af5825321e6c4ba" name="a4efb88d640b634b77af5825321e6c4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efb88d640b634b77af5825321e6c4ba">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

</div>
</div>
<a id="adabd8c4eea861419dc2629610a922e97" name="adabd8c4eea861419dc2629610a922e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabd8c4eea861419dc2629610a922e97">&#9670;&nbsp;</a></span>push_back() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

</div>
</div>
<a id="a696ab4a7073c479bb1ef24c23c3d3d67" name="a696ab4a7073c479bb1ef24c23c3d3d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696ab4a7073c479bb1ef24c23c3d3d67">&#9670;&nbsp;</a></span>sax_parse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="json__fwd_8h.html#ae6eede511f01c9f33342044d36a388fa">input_format_t::json</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate SAX events </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/sax_parse/">https://json.nlohmann.me/api/basic_json/sax_parse/</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>This function is deprecated since 3.8.0 and will be removed in version 4.0.0 of the library. Please use sax_parse(ptr, ptr + len) instead. </dd></dl>

</div>
</div>
<a id="a2eae76ffa6335685fa38190a18806d55" name="a2eae76ffa6335685fa38190a18806d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eae76ffa6335685fa38190a18806d55">&#9670;&nbsp;</a></span>sax_parse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macro__scope_8h.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> bool static SAX bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="json__fwd_8h.html#ae6eede511f01c9f33342044d36a388fa">input_format_t::json</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e2094d16fe8fd49c20eca61fa88d602" name="a4e2094d16fe8fd49c20eca61fa88d602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2094d16fe8fd49c20eca61fa88d602">&#9670;&nbsp;</a></span>sax_parse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , class SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="json__fwd_8h.html#ae6eede511f01c9f33342044d36a388fa">input_format_t::json</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate SAX events </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/sax_parse/">https://json.nlohmann.me/api/basic_json/sax_parse/</a> </dd></dl>

</div>
</div>
<a id="af1bc171c2ec496dcc63c9035354d1138" name="af1bc171c2ec496dcc63c9035354d1138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bc171c2ec496dcc63c9035354d1138">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a7cf28eb944e7c06aa47f0bc3a9d6f454">array_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="a23296c72c9f837e20cfdc28d8018dd57" name="a23296c72c9f837e20cfdc28d8018dd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23296c72c9f837e20cfdc28d8018dd57">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a10e4e8a0166fd47c006b82b20b2dcd7f">binary_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="a2061fc20992f76b6fe4a7d2456391b8f" name="a2061fc20992f76b6fe4a7d2456391b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2061fc20992f76b6fe4a7d2456391b8f">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a770279b71f788fe3f76411eedf5b1956">object_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="a57541a1c736f6ea94fe4a92dd61b3c37" name="a57541a1c736f6ea94fe4a92dd61b3c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57541a1c736f6ea94fe4a92dd61b3c37">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="aa914de665383b10bdd6265e6b63b8d93" name="aa914de665383b10bdd6265e6b63b8d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa914de665383b10bdd6265e6b63b8d93">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="a636ae0a887a94436f43f26c94aa1f748" name="a636ae0a887a94436f43f26c94aa1f748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636ae0a887a94436f43f26c94aa1f748">&#9670;&nbsp;</a></span>swap() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="a2b222d92f075b0033a76a60ccb36269c" name="a2b222d92f075b0033a76a60ccb36269c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b222d92f075b0033a76a60ccb36269c">&#9670;&nbsp;</a></span>to_bjdata() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::uint8_t &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

</div>
</div>
<a id="a9c66ff3a69ef4e4d0d1c136d4226c6af" name="a9c66ff3a69ef4e4d0d1c136d4226c6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c66ff3a69ef4e4d0d1c136d4226c6af">&#9670;&nbsp;</a></span>to_bjdata() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

</div>
</div>
<a id="a9b4a7117f98423b6d92e48951a7e3c55" name="a9b4a7117f98423b6d92e48951a7e3c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4a7117f98423b6d92e48951a7e3c55">&#9670;&nbsp;</a></span>to_bjdata() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

</div>
</div>
<a id="a85f418313f92075a0ab72060bfe4de06" name="a85f418313f92075a0ab72060bfe4de06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f418313f92075a0ab72060bfe4de06">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::uint8_t &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

</div>
</div>
<a id="a62bb643538ab0e016a2f319e22bf4c4d" name="a62bb643538ab0e016a2f319e22bf4c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bb643538ab0e016a2f319e22bf4c4d">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

</div>
</div>
<a id="ad5ff725ab08638fbc83ed7e3c7c41396" name="ad5ff725ab08638fbc83ed7e3c7c41396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ff725ab08638fbc83ed7e3c7c41396">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

</div>
</div>
<a id="a12a270a8c98f23f838837562ddde18a8" name="a12a270a8c98f23f838837562ddde18a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a270a8c98f23f838837562ddde18a8">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::uint8_t &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

</div>
</div>
<a id="a4b49f22c2c0ed2c803c695f328ee5f4f" name="a4b49f22c2c0ed2c803c695f328ee5f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b49f22c2c0ed2c803c695f328ee5f4f">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

</div>
</div>
<a id="a91e6116b577c4a402d0bf59ceb1ce3b6" name="a91e6116b577c4a402d0bf59ceb1ce3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e6116b577c4a402d0bf59ceb1ce3b6">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

</div>
</div>
<a id="a4d510f5c39b036deb96e61c8bef19f31" name="a4d510f5c39b036deb96e61c8bef19f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d510f5c39b036deb96e61c8bef19f31">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::uint8_t &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

</div>
</div>
<a id="a7e3ec809212107cb5809c386c5e3dce3" name="a7e3ec809212107cb5809c386c5e3dce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3ec809212107cb5809c386c5e3dce3">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

</div>
</div>
<a id="ad91a270a87e6aec97c18d44aaddf0d33" name="ad91a270a87e6aec97c18d44aaddf0d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91a270a87e6aec97c18d44aaddf0d33">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

</div>
</div>
<a id="a74a0e7569fb3170e0151e4aca3f4bf3b" name="a74a0e7569fb3170e0151e4aca3f4bf3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a0e7569fb3170e0151e4aca3f4bf3b">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::uint8_t &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

</div>
</div>
<a id="a81aecae4901eb995b22ee6abccf94122" name="a81aecae4901eb995b22ee6abccf94122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81aecae4901eb995b22ee6abccf94122">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

</div>
</div>
<a id="ad7567f6b4b51d3bc1cbe6a80cd6ca9a8" name="ad7567f6b4b51d3bc1cbe6a80cd6ca9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7567f6b4b51d3bc1cbe6a80cd6ca9a8">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

</div>
</div>
<a id="a1338e4eef7282cd57a4a57e034531029" name="a1338e4eef7282cd57a4a57e034531029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1338e4eef7282cd57a4a57e034531029">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type of the JSON value (explicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/type/">https://json.nlohmann.me/api/basic_json/type/</a> </dd></dl>

</div>
</div>
<a id="a7528ae3cfe082b3e6280eb5dfab4700b" name="a7528ae3cfe082b3e6280eb5dfab4700b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7528ae3cfe082b3e6280eb5dfab4700b">&#9670;&nbsp;</a></span>type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hedley_8h.html#a5f2aaec3b681d0a72f7d6e90b70cdcd1">JSON_HEDLEY_RETURNS_NON_NULL</a> const char * <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type as string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/type_name/">https://json.nlohmann.me/api/basic_json/type_name/</a> </dd></dl>

</div>
</div>
<a id="a2db7c9bf454f893d156a7396d527873b" name="a2db7c9bf454f893d156a7396d527873b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db7c9bf454f893d156a7396d527873b">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge_objects</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates a JSON object from another object, overwriting existing keys </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/update/">https://json.nlohmann.me/api/basic_json/update/</a> </dd></dl>

</div>
</div>
<a id="aa1c13ddcc1eb615dc56ebd7cb44791bd" name="aa1c13ddcc1eb615dc56ebd7cb44791bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c13ddcc1eb615dc56ebd7cb44791bd">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge_objects</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates a JSON object from another object, overwriting existing keys </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/update/">https://json.nlohmann.me/api/basic_json/update/</a> </dd></dl>

</div>
</div>
<a id="a8e07f0a0e66b05e7b77b95f623cbfac1" name="a8e07f0a0e66b05e7b77b95f623cbfac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e07f0a0e66b05e7b77b95f623cbfac1">&#9670;&nbsp;</a></span>value() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<a id="af435aab4d160572776d7e66c3809e4b1" name="af435aab4d160572776d7e66c3809e4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af435aab4d160572776d7e66c3809e4b1">&#9670;&nbsp;</a></span>value() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a5def9176cd6361a5b210a6c1a9396c28">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<a id="a3fb507ac4a659d45a9ccdfb67a0646ec" name="a3fb507ac4a659d45a9ccdfb67a0646ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb507ac4a659d45a9ccdfb67a0646ec">&#9670;&nbsp;</a></span>value() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; !<a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<a id="a1460a0f28bedca9050f2259ec6bf86e6" name="a1460a0f28bedca9050f2259ec6bf86e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1460a0f28bedca9050f2259ec6bf86e6">&#9670;&nbsp;</a></span>value() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; !<a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<a id="a58469bce489ece80e50e7ed59fa09484" name="a58469bce489ece80e50e7ed59fa09484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58469bce489ece80e50e7ed59fa09484">&#9670;&nbsp;</a></span>value() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class KeyType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;!<a class="el" href="namespacedetail.html#a06ad3beb30c2c13d70ae518317a3156f">detail::is_json_pointer</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__comparable.html">is_comparable_with_object_key</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<a id="ac7d24993dea7dcd5442465e43b0554cb" name="ac7d24993dea7dcd5442465e43b0554cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d24993dea7dcd5442465e43b0554cb">&#9670;&nbsp;</a></span>value() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class KeyType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;!<a class="el" href="namespacedetail.html#a06ad3beb30c2c13d70ae518317a3156f">detail::is_json_pointer</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__comparable.html">is_comparable_with_object_key</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a1076517313bebd9317abb5f8ae1674d3" name="a1076517313bebd9317abb5f8ae1674d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1076517313bebd9317abb5f8ae1674d3">&#9670;&nbsp;</a></span>::wpi::detail::binary_reader</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename InputType , typename SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::wpi::detail::binary_reader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae825bd970ff2124e96e2715b44d74b0d" name="ae825bd970ff2124e96e2715b44d74b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae825bd970ff2124e96e2715b44d74b0d">&#9670;&nbsp;</a></span>::wpi::detail::binary_writer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename CharType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::wpi::detail::binary_writer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93f1e737927201b292c4d4e1935614ce" name="a93f1e737927201b292c4d4e1935614ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f1e737927201b292c4d4e1935614ce">&#9670;&nbsp;</a></span>::wpi::detail::exception</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="_third_party_notices_8txt.html#a5378875817b4fe889c3bbcd85fea1862">::wpi::detail::exception</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95d20ee95fa3b90049a0b658740940df" name="a95d20ee95fa3b90049a0b658740940df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d20ee95fa3b90049a0b658740940df">&#9670;&nbsp;</a></span>::wpi::detail::iter_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::wpi::detail::iter_impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01207613d33f5fe85434326323472e69" name="a01207613d33f5fe85434326323472e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01207613d33f5fe85434326323472e69">&#9670;&nbsp;</a></span>::wpi::detail::json_sax_dom_callback_parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::wpi::detail::json_sax_dom_callback_parser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a925bb3befb53793ac51d4cfddb4c6a86" name="a925bb3befb53793ac51d4cfddb4c6a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925bb3befb53793ac51d4cfddb4c6a86">&#9670;&nbsp;</a></span>::wpi::detail::json_sax_dom_parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::wpi::detail::json_sax_dom_parser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa6d99ed21debf20602cc7eb9f2ef01a" name="aaa6d99ed21debf20602cc7eb9f2ef01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6d99ed21debf20602cc7eb9f2ef01a">&#9670;&nbsp;</a></span>::wpi::detail::parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::wpi::detail::parser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51c40387c5ebc1df2bbfdd83f01fc9e1" name="a51c40387c5ebc1df2bbfdd83f01fc9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c40387c5ebc1df2bbfdd83f01fc9e1">&#9670;&nbsp;</a></span>::wpi::json_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::wpi::json_pointer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6275ed57bae6866cdf5db5370a7ad47c" name="a6275ed57bae6866cdf5db5370a7ad47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6275ed57bae6866cdf5db5370a7ad47c">&#9670;&nbsp;</a></span>detail::external_constructor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structdetail_1_1external__constructor.html">detail::external_constructor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9907af448f7ff794120033e132025f6" name="af9907af448f7ff794120033e132025f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9907af448f7ff794120033e132025f6">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_gtgt/">https://json.nlohmann.me/api/basic_json/operator_gtgt/</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>This stream operator is deprecated since 3.0.0 and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classbasic__json.html#aea0de29387d532e0bc5f2475cb83995d" title="deserialize from stream">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>

</div>
</div>
<a id="aea0de29387d532e0bc5f2475cb83995d" name="aea0de29387d532e0bc5f2475cb83995d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0de29387d532e0bc5f2475cb83995d">&#9670;&nbsp;</a></span>operator&gt;&gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_gtgt/">https://json.nlohmann.me/api/basic_json/operator_gtgt/</a> </dd></dl>

</div>
</div>
<a id="aee0ae36cbfb0336832ebc0374c3c7679" name="aee0ae36cbfb0336832ebc0374c3c7679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0ae36cbfb0336832ebc0374c3c7679">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a39b01253ca65e8f5abdc1796d6ee0012" name="a39b01253ca65e8f5abdc1796d6ee0012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b01253ca65e8f5abdc1796d6ee0012">&#9670;&nbsp;</a></span>__pad2__</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macro__scope_8h.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::__pad2__</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e8bca0d3d745150dbaae538443bb626" name="a7e8bca0d3d745150dbaae538443bb626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8bca0d3d745150dbaae538443bb626">&#9670;&nbsp;</a></span>__pad3__</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macro__scope_8h.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::__pad3__</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe6a2b3e624ac8772519963bcfb8fb56" name="abe6a2b3e624ac8772519963bcfb8fb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6a2b3e624ac8772519963bcfb8fb56">&#9670;&nbsp;</a></span>inverse</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macro__scope_8h.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::inverse</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34bc6074bd3f9ac2bdab12ebc02d70f5" name="a34bc6074bd3f9ac2bdab12ebc02d70f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bc6074bd3f9ac2bdab12ebc02d70f5">&#9670;&nbsp;</a></span>m_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">json_value <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::m_value = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the value of the current element </p>

</div>
</div>
<a id="ac83f2e1cec130719f862008b9e16acee" name="ac83f2e1cec130719f862008b9e16acee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83f2e1cec130719f862008b9e16acee">&#9670;&nbsp;</a></span>rhs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macro__scope_8h.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::rhs</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/allwpilib/allwpilib/wpiutil/src/main/native/thirdparty/json/include/wpi/<a class="el" href="json_8h_source.html">json.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classbasic__json.html">basic_json</a></li>
    <li class="footer">Generated on Fri Jun 28 2024 05:29:45 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
