<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: Eigen::internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2024.3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespace_eigen_1_1internal.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Eigen::internal Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1is__exp__known__type.html">is_exp_known_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1is__exp__known__type_3_01double_01_4.html">is_exp_known_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1is__exp__known__type_3_01float_01_4.html">is_exp_known_type&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1is__exp__known__type_3_01long_01double_01_4.html">is_exp_known_type&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__exp__compute_u_v.html">matrix_exp_computeUV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (17,17)-Pad&eacute; approximant to the exponential.  <a href="struct_eigen_1_1internal_1_1matrix__exp__compute_u_v.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__exp__compute_u_v_3_01_matrix_type_00_01double_01_4.html">matrix_exp_computeUV&lt; MatrixType, double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__exp__compute_u_v_3_01_matrix_type_00_01float_01_4.html">matrix_exp_computeUV&lt; MatrixType, float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__exp__compute_u_v_3_01_matrix_type_00_01long_01double_01_4.html">matrix_exp_computeUV&lt; MatrixType, long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__function__compute.html">matrix_function_compute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix functions.  <a href="struct_eigen_1_1internal_1_1matrix__function__compute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__function__compute_3_01_matrix_type_00_010_01_4.html">matrix_function_compute&lt; MatrixType, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__function__compute_3_01_matrix_type_00_011_01_4.html">matrix_function_compute&lt; MatrixType, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__log__max__pade__degree.html">matrix_log_max_pade_degree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__log__min__pade__degree.html">matrix_log_min_pade_degree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__sqrt__compute.html">matrix_sqrt_compute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for computing matrix square roots of general matrices.  <a href="struct_eigen_1_1internal_1_1matrix__sqrt__compute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__sqrt__compute_3_01_matrix_type_00_010_01_4.html">matrix_sqrt_compute&lt; MatrixType, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1matrix__sqrt__compute_3_01_matrix_type_00_011_01_4.html">matrix_sqrt_compute&lt; MatrixType, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op.html">MatrixExponentialScalingOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling operator.  <a href="struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1internal_1_1_matrix_function_atomic.html">MatrixFunctionAtomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for computing matrix functions of atomic matrices.  <a href="class_eigen_1_1internal_1_1_matrix_function_atomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1internal_1_1_matrix_logarithm_atomic.html">MatrixLogarithmAtomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for computing matrix logarithm of atomic matrices.  <a href="class_eigen_1_1internal_1_1_matrix_logarithm_atomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1traits_3_01_matrix_complex_power_return_value_3_01_derived_01_4_01_4.html">traits&lt; MatrixComplexPowerReturnValue&lt; Derived &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1traits_3_01_matrix_exponential_return_value_3_01_derived_01_4_01_4.html">traits&lt; MatrixExponentialReturnValue&lt; Derived &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1traits_3_01_matrix_function_return_value_3_01_derived_01_4_01_4.html">traits&lt; MatrixFunctionReturnValue&lt; Derived &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1traits_3_01_matrix_logarithm_return_value_3_01_derived_01_4_01_4.html">traits&lt; MatrixLogarithmReturnValue&lt; Derived &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1traits_3_01_matrix_power_parentheses_return_value_3_01_matrix_power_type_01_4_01_4.html">traits&lt; MatrixPowerParenthesesReturnValue&lt; MatrixPowerType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1traits_3_01_matrix_power_return_value_3_01_derived_01_4_01_4.html">traits&lt; MatrixPowerReturnValue&lt; Derived &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1internal_1_1traits_3_01_matrix_square_root_return_value_3_01_derived_01_4_01_4.html">traits&lt; MatrixSquareRootReturnValue&lt; Derived &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a92f37da4b71409d05402a1475639314c"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:a92f37da4b71409d05402a1475639314c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a92f37da4b71409d05402a1475639314c">matrix_sqrt_quasi_triangular_2x2_diagonal_block</a> (const MatrixType &amp;T, Index i, ResultType &amp;sqrtT)</td></tr>
<tr class="separator:a92f37da4b71409d05402a1475639314c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab017c7f19f2a39bdb8e1ef75da19282f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:ab017c7f19f2a39bdb8e1ef75da19282f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#ab017c7f19f2a39bdb8e1ef75da19282f">matrix_sqrt_quasi_triangular_1x1_off_diagonal_block</a> (const MatrixType &amp;T, Index i, Index j, ResultType &amp;sqrtT)</td></tr>
<tr class="separator:ab017c7f19f2a39bdb8e1ef75da19282f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51428fd358b479e7f0b14efb4fea5932"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:a51428fd358b479e7f0b14efb4fea5932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a51428fd358b479e7f0b14efb4fea5932">matrix_sqrt_quasi_triangular_1x2_off_diagonal_block</a> (const MatrixType &amp;T, Index i, Index j, ResultType &amp;sqrtT)</td></tr>
<tr class="separator:a51428fd358b479e7f0b14efb4fea5932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde5a081fe6c25ef0ffc3d89bc59f117"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:acde5a081fe6c25ef0ffc3d89bc59f117"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#acde5a081fe6c25ef0ffc3d89bc59f117">matrix_sqrt_quasi_triangular_2x1_off_diagonal_block</a> (const MatrixType &amp;T, Index i, Index j, ResultType &amp;sqrtT)</td></tr>
<tr class="separator:acde5a081fe6c25ef0ffc3d89bc59f117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691211492c8b69df5c7391bd1de411c4"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a691211492c8b69df5c7391bd1de411c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a691211492c8b69df5c7391bd1de411c4">matrix_sqrt_quasi_triangular_solve_auxiliary_equation</a> (MatrixType &amp;X, const MatrixType &amp;A, const MatrixType &amp;B, const MatrixType &amp;C)</td></tr>
<tr class="separator:a691211492c8b69df5c7391bd1de411c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97eecfb57cb62e6e0b046e38e2ee4549"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:a97eecfb57cb62e6e0b046e38e2ee4549"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a97eecfb57cb62e6e0b046e38e2ee4549">matrix_sqrt_quasi_triangular_2x2_off_diagonal_block</a> (const MatrixType &amp;T, Index i, Index j, ResultType &amp;sqrtT)</td></tr>
<tr class="separator:a97eecfb57cb62e6e0b046e38e2ee4549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5c9733af465bc14851019818a5d2b3"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:a8e5c9733af465bc14851019818a5d2b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a8e5c9733af465bc14851019818a5d2b3">matrix_sqrt_quasi_triangular_diagonal</a> (const MatrixType &amp;T, ResultType &amp;sqrtT)</td></tr>
<tr class="separator:a8e5c9733af465bc14851019818a5d2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c0b49fec5ce44af43283d7f541d341"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:a95c0b49fec5ce44af43283d7f541d341"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a95c0b49fec5ce44af43283d7f541d341">matrix_sqrt_quasi_triangular_off_diagonal</a> (const MatrixType &amp;T, ResultType &amp;sqrtT)</td></tr>
<tr class="separator:a95c0b49fec5ce44af43283d7f541d341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb8d312c017f94570a52317fd1ece5f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a1cb8d312c017f94570a52317fd1ece5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a1cb8d312c017f94570a52317fd1ece5f">matrix_log_compute_2x2</a> (const MatrixType &amp;A, MatrixType &amp;result)</td></tr>
<tr class="memdesc:a1cb8d312c017f94570a52317fd1ece5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute logarithm of 2x2 triangular matrix.  <a href="namespace_eigen_1_1internal.html#a1cb8d312c017f94570a52317fd1ece5f">More...</a><br /></td></tr>
<tr class="separator:a1cb8d312c017f94570a52317fd1ece5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0091d6d89ad60b1117bbb1b4b9901d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#ae0091d6d89ad60b1117bbb1b4b9901d0">matrix_log_get_pade_degree</a> (float normTminusI)</td></tr>
<tr class="separator:ae0091d6d89ad60b1117bbb1b4b9901d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdde7861546c148b2067fd94b3933f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a7cdde7861546c148b2067fd94b3933f0">matrix_log_get_pade_degree</a> (double normTminusI)</td></tr>
<tr class="separator:a7cdde7861546c148b2067fd94b3933f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cb311dc4965edfa087bc35a9ee99ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#ab6cb311dc4965edfa087bc35a9ee99ed">matrix_log_get_pade_degree</a> (long double normTminusI)</td></tr>
<tr class="separator:ab6cb311dc4965edfa087bc35a9ee99ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366cdd93d3035b0053cc8b3bff77f2a4"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a366cdd93d3035b0053cc8b3bff77f2a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a366cdd93d3035b0053cc8b3bff77f2a4">matrix_log_compute_pade</a> (MatrixType &amp;result, const MatrixType &amp;T, int degree)</td></tr>
<tr class="separator:a366cdd93d3035b0053cc8b3bff77f2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2de7acbbff34ec236ee5e9fdb2eee38"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:ac2de7acbbff34ec236ee5e9fdb2eee38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#ac2de7acbbff34ec236ee5e9fdb2eee38">matrix_log_compute_big</a> (const MatrixType &amp;A, MatrixType &amp;result)</td></tr>
<tr class="memdesc:ac2de7acbbff34ec236ee5e9fdb2eee38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute logarithm of triangular matrices with size &gt; 2.  <a href="namespace_eigen_1_1internal.html#ac2de7acbbff34ec236ee5e9fdb2eee38">More...</a><br /></td></tr>
<tr class="separator:ac2de7acbbff34ec236ee5e9fdb2eee38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91bbd019ccf1640f8707dd0926a715a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:ae91bbd019ccf1640f8707dd0926a715a"><td class="memTemplItemLeft" align="right" valign="top">NumTraits&lt; typenameMatrixType::Scalar &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#ae91bbd019ccf1640f8707dd0926a715a">matrix_function_compute_mu</a> (const MatrixType &amp;A)</td></tr>
<tr class="separator:ae91bbd019ccf1640f8707dd0926a715a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cdbae9f4f166fae876c54b97c0f2bb"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename ListOfClusters &gt; </td></tr>
<tr class="memitem:af9cdbae9f4f166fae876c54b97c0f2bb"><td class="memTemplItemLeft" align="right" valign="top">ListOfClusters::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#af9cdbae9f4f166fae876c54b97c0f2bb">matrix_function_find_cluster</a> (Index key, ListOfClusters &amp;clusters)</td></tr>
<tr class="memdesc:af9cdbae9f4f166fae876c54b97c0f2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find cluster in <code>clusters</code> containing some value.  <a href="namespace_eigen_1_1internal.html#af9cdbae9f4f166fae876c54b97c0f2bb">More...</a><br /></td></tr>
<tr class="separator:af9cdbae9f4f166fae876c54b97c0f2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9291a6ab4fe0ad1346049a8f2feddeaa"><td class="memTemplParams" colspan="2">template&lt;typename EivalsType , typename Cluster &gt; </td></tr>
<tr class="memitem:a9291a6ab4fe0ad1346049a8f2feddeaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a9291a6ab4fe0ad1346049a8f2feddeaa">matrix_function_partition_eigenvalues</a> (const EivalsType &amp;eivals, std::list&lt; Cluster &gt; &amp;clusters)</td></tr>
<tr class="memdesc:a9291a6ab4fe0ad1346049a8f2feddeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition eigenvalues in clusters of ei'vals close to each other.  <a href="namespace_eigen_1_1internal.html#a9291a6ab4fe0ad1346049a8f2feddeaa">More...</a><br /></td></tr>
<tr class="separator:a9291a6ab4fe0ad1346049a8f2feddeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1073ba7ac499827baa04c814e4251326"><td class="memTemplParams" colspan="2">template&lt;typename ListOfClusters , typename Index &gt; </td></tr>
<tr class="memitem:a1073ba7ac499827baa04c814e4251326"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a1073ba7ac499827baa04c814e4251326">matrix_function_compute_cluster_size</a> (const ListOfClusters &amp;clusters, Matrix&lt; Index, Dynamic, 1 &gt; &amp;clusterSize)</td></tr>
<tr class="memdesc:a1073ba7ac499827baa04c814e4251326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute size of each cluster given a partitioning.  <a href="namespace_eigen_1_1internal.html#a1073ba7ac499827baa04c814e4251326">More...</a><br /></td></tr>
<tr class="separator:a1073ba7ac499827baa04c814e4251326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2144f635d30028a25e7eb3510c315ad3"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a2144f635d30028a25e7eb3510c315ad3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a2144f635d30028a25e7eb3510c315ad3">matrix_function_compute_block_start</a> (const VectorType &amp;clusterSize, VectorType &amp;blockStart)</td></tr>
<tr class="memdesc:a2144f635d30028a25e7eb3510c315ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute start of each block using clusterSize.  <a href="namespace_eigen_1_1internal.html#a2144f635d30028a25e7eb3510c315ad3">More...</a><br /></td></tr>
<tr class="separator:a2144f635d30028a25e7eb3510c315ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade67364a006320cd7103f0f3366def09"><td class="memTemplParams" colspan="2">template&lt;typename EivalsType , typename ListOfClusters , typename VectorType &gt; </td></tr>
<tr class="memitem:ade67364a006320cd7103f0f3366def09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#ade67364a006320cd7103f0f3366def09">matrix_function_compute_map</a> (const EivalsType &amp;eivals, const ListOfClusters &amp;clusters, VectorType &amp;eivalToCluster)</td></tr>
<tr class="memdesc:ade67364a006320cd7103f0f3366def09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mapping of eigenvalue indices to cluster indices.  <a href="namespace_eigen_1_1internal.html#ade67364a006320cd7103f0f3366def09">More...</a><br /></td></tr>
<tr class="separator:ade67364a006320cd7103f0f3366def09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0434fe5b0ec47e69b8e351ef9e131bcd"><td class="memTemplParams" colspan="2">template&lt;typename DynVectorType , typename VectorType &gt; </td></tr>
<tr class="memitem:a0434fe5b0ec47e69b8e351ef9e131bcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a0434fe5b0ec47e69b8e351ef9e131bcd">matrix_function_compute_permutation</a> (const DynVectorType &amp;blockStart, const DynVectorType &amp;eivalToCluster, VectorType &amp;permutation)</td></tr>
<tr class="memdesc:a0434fe5b0ec47e69b8e351ef9e131bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute permutation which groups ei'vals in same cluster together.  <a href="namespace_eigen_1_1internal.html#a0434fe5b0ec47e69b8e351ef9e131bcd">More...</a><br /></td></tr>
<tr class="separator:a0434fe5b0ec47e69b8e351ef9e131bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cacdc2f9b480da246258bc9399aa2c"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename MatrixType &gt; </td></tr>
<tr class="memitem:a59cacdc2f9b480da246258bc9399aa2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a59cacdc2f9b480da246258bc9399aa2c">matrix_function_permute_schur</a> (VectorType &amp;permutation, MatrixType &amp;U, MatrixType &amp;T)</td></tr>
<tr class="memdesc:a59cacdc2f9b480da246258bc9399aa2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute Schur decomposition in U and T according to permutation.  <a href="namespace_eigen_1_1internal.html#a59cacdc2f9b480da246258bc9399aa2c">More...</a><br /></td></tr>
<tr class="separator:a59cacdc2f9b480da246258bc9399aa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e617df189868a791e44d2c4e94403f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename AtomicType , typename VectorType &gt; </td></tr>
<tr class="memitem:a53e617df189868a791e44d2c4e94403f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a53e617df189868a791e44d2c4e94403f">matrix_function_compute_block_atomic</a> (const MatrixType &amp;T, AtomicType &amp;atomic, const VectorType &amp;blockStart, const VectorType &amp;clusterSize, MatrixType &amp;fT)</td></tr>
<tr class="memdesc:a53e617df189868a791e44d2c4e94403f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute block diagonal part of matrix function.  <a href="namespace_eigen_1_1internal.html#a53e617df189868a791e44d2c4e94403f">More...</a><br /></td></tr>
<tr class="separator:a53e617df189868a791e44d2c4e94403f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7e5b9803071057e7ed4e887da4a1bb"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a9f7e5b9803071057e7ed4e887da4a1bb"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a9f7e5b9803071057e7ed4e887da4a1bb">matrix_function_solve_triangular_sylvester</a> (const MatrixType &amp;A, const MatrixType &amp;B, const MatrixType &amp;C)</td></tr>
<tr class="memdesc:a9f7e5b9803071057e7ed4e887da4a1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a triangular Sylvester equation AX + XB = C.  <a href="namespace_eigen_1_1internal.html#a9f7e5b9803071057e7ed4e887da4a1bb">More...</a><br /></td></tr>
<tr class="separator:a9f7e5b9803071057e7ed4e887da4a1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff76c47bde59d8af688e5925bed8f17"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a8ff76c47bde59d8af688e5925bed8f17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a8ff76c47bde59d8af688e5925bed8f17">matrix_function_compute_above_diagonal</a> (const MatrixType &amp;T, const VectorType &amp;blockStart, const VectorType &amp;clusterSize, MatrixType &amp;fT)</td></tr>
<tr class="memdesc:a8ff76c47bde59d8af688e5925bed8f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute part of matrix function above block diagonal.  <a href="namespace_eigen_1_1internal.html#a8ff76c47bde59d8af688e5925bed8f17">More...</a><br /></td></tr>
<tr class="separator:a8ff76c47bde59d8af688e5925bed8f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7bafccf7fa66d965ab6c59444a39c3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a0e7bafccf7fa66d965ab6c59444a39c3"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a0e7bafccf7fa66d965ab6c59444a39c3">stem_function_exp</a> (Scalar x, int)</td></tr>
<tr class="memdesc:a0e7bafccf7fa66d965ab6c59444a39c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exponential function (and its derivatives).  <a href="namespace_eigen_1_1internal.html#a0e7bafccf7fa66d965ab6c59444a39c3">More...</a><br /></td></tr>
<tr class="separator:a0e7bafccf7fa66d965ab6c59444a39c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9727c15ffb97a40df226fce93e2628b3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a9727c15ffb97a40df226fce93e2628b3"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a9727c15ffb97a40df226fce93e2628b3">stem_function_cos</a> (Scalar x, int n)</td></tr>
<tr class="memdesc:a9727c15ffb97a40df226fce93e2628b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cosine (and its derivatives).  <a href="namespace_eigen_1_1internal.html#a9727c15ffb97a40df226fce93e2628b3">More...</a><br /></td></tr>
<tr class="separator:a9727c15ffb97a40df226fce93e2628b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297dc38f5c9b80e2a1da7dcf2a453c90"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a297dc38f5c9b80e2a1da7dcf2a453c90"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a297dc38f5c9b80e2a1da7dcf2a453c90">stem_function_sin</a> (Scalar x, int n)</td></tr>
<tr class="memdesc:a297dc38f5c9b80e2a1da7dcf2a453c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sine (and its derivatives).  <a href="namespace_eigen_1_1internal.html#a297dc38f5c9b80e2a1da7dcf2a453c90">More...</a><br /></td></tr>
<tr class="separator:a297dc38f5c9b80e2a1da7dcf2a453c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7949e5c95ec574eff5c4229da36846"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aab7949e5c95ec574eff5c4229da36846"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#aab7949e5c95ec574eff5c4229da36846">stem_function_cosh</a> (Scalar x, int n)</td></tr>
<tr class="memdesc:aab7949e5c95ec574eff5c4229da36846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic cosine (and its derivatives).  <a href="namespace_eigen_1_1internal.html#aab7949e5c95ec574eff5c4229da36846">More...</a><br /></td></tr>
<tr class="separator:aab7949e5c95ec574eff5c4229da36846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2855d150c9eebb8ed6cb63a292dda0d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ab2855d150c9eebb8ed6cb63a292dda0d"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#ab2855d150c9eebb8ed6cb63a292dda0d">stem_function_sinh</a> (Scalar x, int n)</td></tr>
<tr class="memdesc:ab2855d150c9eebb8ed6cb63a292dda0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic sine (and its derivatives).  <a href="namespace_eigen_1_1internal.html#ab2855d150c9eebb8ed6cb63a292dda0d">More...</a><br /></td></tr>
<tr class="separator:ab2855d150c9eebb8ed6cb63a292dda0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6cf2e01b6fb376d33b9bb8183e5777"><td class="memTemplParams" colspan="2">template&lt;typename MatA , typename MatU , typename MatV &gt; </td></tr>
<tr class="memitem:a7e6cf2e01b6fb376d33b9bb8183e5777"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a7e6cf2e01b6fb376d33b9bb8183e5777">matrix_exp_pade3</a> (const MatA &amp;A, MatU &amp;U, MatV &amp;V)</td></tr>
<tr class="memdesc:a7e6cf2e01b6fb376d33b9bb8183e5777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (3,3)-Pad&eacute; approximant to the exponential.  <a href="namespace_eigen_1_1internal.html#a7e6cf2e01b6fb376d33b9bb8183e5777">More...</a><br /></td></tr>
<tr class="separator:a7e6cf2e01b6fb376d33b9bb8183e5777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4992d182490219270a24aaa8285e63a"><td class="memTemplParams" colspan="2">template&lt;typename MatA , typename MatU , typename MatV &gt; </td></tr>
<tr class="memitem:af4992d182490219270a24aaa8285e63a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#af4992d182490219270a24aaa8285e63a">matrix_exp_pade5</a> (const MatA &amp;A, MatU &amp;U, MatV &amp;V)</td></tr>
<tr class="memdesc:af4992d182490219270a24aaa8285e63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (5,5)-Pad&eacute; approximant to the exponential.  <a href="namespace_eigen_1_1internal.html#af4992d182490219270a24aaa8285e63a">More...</a><br /></td></tr>
<tr class="separator:af4992d182490219270a24aaa8285e63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abecb439e6cb1b5188828cdb7e0ab60"><td class="memTemplParams" colspan="2">template&lt;typename MatA , typename MatU , typename MatV &gt; </td></tr>
<tr class="memitem:a1abecb439e6cb1b5188828cdb7e0ab60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a1abecb439e6cb1b5188828cdb7e0ab60">matrix_exp_pade7</a> (const MatA &amp;A, MatU &amp;U, MatV &amp;V)</td></tr>
<tr class="memdesc:a1abecb439e6cb1b5188828cdb7e0ab60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (7,7)-Pad&eacute; approximant to the exponential.  <a href="namespace_eigen_1_1internal.html#a1abecb439e6cb1b5188828cdb7e0ab60">More...</a><br /></td></tr>
<tr class="separator:a1abecb439e6cb1b5188828cdb7e0ab60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218447e97bf869bf354f92e020a7355a"><td class="memTemplParams" colspan="2">template&lt;typename MatA , typename MatU , typename MatV &gt; </td></tr>
<tr class="memitem:a218447e97bf869bf354f92e020a7355a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a218447e97bf869bf354f92e020a7355a">matrix_exp_pade9</a> (const MatA &amp;A, MatU &amp;U, MatV &amp;V)</td></tr>
<tr class="memdesc:a218447e97bf869bf354f92e020a7355a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (9,9)-Pad&eacute; approximant to the exponential.  <a href="namespace_eigen_1_1internal.html#a218447e97bf869bf354f92e020a7355a">More...</a><br /></td></tr>
<tr class="separator:a218447e97bf869bf354f92e020a7355a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d0962a143c96343984440db683905a"><td class="memTemplParams" colspan="2">template&lt;typename MatA , typename MatU , typename MatV &gt; </td></tr>
<tr class="memitem:ae7d0962a143c96343984440db683905a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#ae7d0962a143c96343984440db683905a">matrix_exp_pade13</a> (const MatA &amp;A, MatU &amp;U, MatV &amp;V)</td></tr>
<tr class="memdesc:ae7d0962a143c96343984440db683905a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (13,13)-Pad&eacute; approximant to the exponential.  <a href="namespace_eigen_1_1internal.html#ae7d0962a143c96343984440db683905a">More...</a><br /></td></tr>
<tr class="separator:ae7d0962a143c96343984440db683905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f2d6a505f108b760c422f937f49924"><td class="memTemplParams" colspan="2">template&lt;typename ArgType , typename ResultType &gt; </td></tr>
<tr class="memitem:a31f2d6a505f108b760c422f937f49924"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a31f2d6a505f108b760c422f937f49924">matrix_exp_compute</a> (const ArgType &amp;<a class="el" href="core_8h.html#a2c8e80c1b1c8b7747e99b8e9a24a0429">arg</a>, ResultType &amp;result, true_type)</td></tr>
<tr class="separator:a31f2d6a505f108b760c422f937f49924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927766ddb1b8b0f0b17e4c982bc50c72"><td class="memTemplParams" colspan="2">template&lt;typename ArgType , typename ResultType &gt; </td></tr>
<tr class="memitem:a927766ddb1b8b0f0b17e4c982bc50c72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a927766ddb1b8b0f0b17e4c982bc50c72">matrix_exp_compute</a> (const ArgType &amp;<a class="el" href="core_8h.html#a2c8e80c1b1c8b7747e99b8e9a24a0429">arg</a>, ResultType &amp;result, false_type)</td></tr>
<tr class="separator:a927766ddb1b8b0f0b17e4c982bc50c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a83aececb2dc32d30c1aa55f9aa5532d9"><td class="memItemLeft" align="right" valign="top">static const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1internal.html#a83aececb2dc32d30c1aa55f9aa5532d9">matrix_function_separation</a> = 0.1f</td></tr>
<tr class="memdesc:a83aececb2dc32d30c1aa55f9aa5532d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum distance allowed between eigenvalues to be considered "close".  <a href="namespace_eigen_1_1internal.html#a83aececb2dc32d30c1aa55f9aa5532d9">More...</a><br /></td></tr>
<tr class="separator:a83aececb2dc32d30c1aa55f9aa5532d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a927766ddb1b8b0f0b17e4c982bc50c72" name="a927766ddb1b8b0f0b17e4c982bc50c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927766ddb1b8b0f0b17e4c982bc50c72">&#9670;&nbsp;</a></span>matrix_exp_compute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_compute </td>
          <td>(</td>
          <td class="paramtype">const ArgType &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31f2d6a505f108b760c422f937f49924" name="a31f2d6a505f108b760c422f937f49924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f2d6a505f108b760c422f937f49924">&#9670;&nbsp;</a></span>matrix_exp_compute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_compute </td>
          <td>(</td>
          <td class="paramtype">const ArgType &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7d0962a143c96343984440db683905a" name="ae7d0962a143c96343984440db683905a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d0962a143c96343984440db683905a">&#9670;&nbsp;</a></span>matrix_exp_pade13()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatA , typename MatU , typename MatV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_pade13 </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the (13,13)-Pad&eacute; approximant to the exponential. </p>
<p >After exit, \( (V+U)(V-U)^{-1} \) is the Pad&eacute; approximant of \( \exp(A) \) around \( A = 0 \). </p>

</div>
</div>
<a id="a7e6cf2e01b6fb376d33b9bb8183e5777" name="a7e6cf2e01b6fb376d33b9bb8183e5777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6cf2e01b6fb376d33b9bb8183e5777">&#9670;&nbsp;</a></span>matrix_exp_pade3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatA , typename MatU , typename MatV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_pade3 </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the (3,3)-Pad&eacute; approximant to the exponential. </p>
<p >After exit, \( (V+U)(V-U)^{-1} \) is the Pad&eacute; approximant of \( \exp(A) \) around \( A = 0 \). </p>

</div>
</div>
<a id="af4992d182490219270a24aaa8285e63a" name="af4992d182490219270a24aaa8285e63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4992d182490219270a24aaa8285e63a">&#9670;&nbsp;</a></span>matrix_exp_pade5()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatA , typename MatU , typename MatV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_pade5 </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the (5,5)-Pad&eacute; approximant to the exponential. </p>
<p >After exit, \( (V+U)(V-U)^{-1} \) is the Pad&eacute; approximant of \( \exp(A) \) around \( A = 0 \). </p>

</div>
</div>
<a id="a1abecb439e6cb1b5188828cdb7e0ab60" name="a1abecb439e6cb1b5188828cdb7e0ab60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abecb439e6cb1b5188828cdb7e0ab60">&#9670;&nbsp;</a></span>matrix_exp_pade7()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatA , typename MatU , typename MatV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_pade7 </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the (7,7)-Pad&eacute; approximant to the exponential. </p>
<p >After exit, \( (V+U)(V-U)^{-1} \) is the Pad&eacute; approximant of \( \exp(A) \) around \( A = 0 \). </p>

</div>
</div>
<a id="a218447e97bf869bf354f92e020a7355a" name="a218447e97bf869bf354f92e020a7355a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218447e97bf869bf354f92e020a7355a">&#9670;&nbsp;</a></span>matrix_exp_pade9()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatA , typename MatU , typename MatV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_pade9 </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the (9,9)-Pad&eacute; approximant to the exponential. </p>
<p >After exit, \( (V+U)(V-U)^{-1} \) is the Pad&eacute; approximant of \( \exp(A) \) around \( A = 0 \). </p>

</div>
</div>
<a id="a8ff76c47bde59d8af688e5925bed8f17" name="a8ff76c47bde59d8af688e5925bed8f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff76c47bde59d8af688e5925bed8f17">&#9670;&nbsp;</a></span>matrix_function_compute_above_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_function_compute_above_diagonal </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>blockStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>clusterSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>fT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute part of matrix function above block diagonal. </p>
<p >This routine completes the computation of <code>fT</code>, denoting a matrix function applied to the triangular matrix <code>T</code>. It assumes that the block diagonal part of <code>fT</code> has already been computed. The part below the diagonal is zero, because <code>T</code> is upper triangular. </p>

</div>
</div>
<a id="a53e617df189868a791e44d2c4e94403f" name="a53e617df189868a791e44d2c4e94403f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e617df189868a791e44d2c4e94403f">&#9670;&nbsp;</a></span>matrix_function_compute_block_atomic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename AtomicType , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_function_compute_block_atomic </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtomicType &amp;&#160;</td>
          <td class="paramname"><em>atomic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>blockStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>clusterSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>fT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute block diagonal part of matrix function. </p>
<p >This routine computes the matrix function applied to the block diagonal part of <code>T</code> (which should be upper triangular), with the blocking given by <code>blockStart</code> and <code>clusterSize</code>. The matrix function of each diagonal block is computed by <code>atomic</code>. The off-diagonal parts of <code>fT</code> are set to zero. </p>

</div>
</div>
<a id="a2144f635d30028a25e7eb3510c315ad3" name="a2144f635d30028a25e7eb3510c315ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2144f635d30028a25e7eb3510c315ad3">&#9670;&nbsp;</a></span>matrix_function_compute_block_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_function_compute_block_start </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>clusterSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>blockStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute start of each block using clusterSize. </p>

</div>
</div>
<a id="a1073ba7ac499827baa04c814e4251326" name="a1073ba7ac499827baa04c814e4251326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1073ba7ac499827baa04c814e4251326">&#9670;&nbsp;</a></span>matrix_function_compute_cluster_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ListOfClusters , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_function_compute_cluster_size </td>
          <td>(</td>
          <td class="paramtype">const ListOfClusters &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix&lt; Index, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusterSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute size of each cluster given a partitioning. </p>

</div>
</div>
<a id="ade67364a006320cd7103f0f3366def09" name="ade67364a006320cd7103f0f3366def09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade67364a006320cd7103f0f3366def09">&#9670;&nbsp;</a></span>matrix_function_compute_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EivalsType , typename ListOfClusters , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_function_compute_map </td>
          <td>(</td>
          <td class="paramtype">const EivalsType &amp;&#160;</td>
          <td class="paramname"><em>eivals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ListOfClusters &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>eivalToCluster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mapping of eigenvalue indices to cluster indices. </p>

</div>
</div>
<a id="ae91bbd019ccf1640f8707dd0926a715a" name="ae91bbd019ccf1640f8707dd0926a715a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91bbd019ccf1640f8707dd0926a715a">&#9670;&nbsp;</a></span>matrix_function_compute_mu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NumTraits&lt; typenameMatrixType::Scalar &gt;::Real Eigen::internal::matrix_function_compute_mu </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0434fe5b0ec47e69b8e351ef9e131bcd" name="a0434fe5b0ec47e69b8e351ef9e131bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0434fe5b0ec47e69b8e351ef9e131bcd">&#9670;&nbsp;</a></span>matrix_function_compute_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DynVectorType , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_function_compute_permutation </td>
          <td>(</td>
          <td class="paramtype">const DynVectorType &amp;&#160;</td>
          <td class="paramname"><em>blockStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DynVectorType &amp;&#160;</td>
          <td class="paramname"><em>eivalToCluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute permutation which groups ei'vals in same cluster together. </p>

</div>
</div>
<a id="af9cdbae9f4f166fae876c54b97c0f2bb" name="af9cdbae9f4f166fae876c54b97c0f2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cdbae9f4f166fae876c54b97c0f2bb">&#9670;&nbsp;</a></span>matrix_function_find_cluster()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index , typename ListOfClusters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ListOfClusters::iterator Eigen::internal::matrix_function_find_cluster </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListOfClusters &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find cluster in <code>clusters</code> containing some value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Value to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to cluster containing <code>key</code>, or <code>clusters.end()</code> if no cluster in <code>m_clusters</code> contains <code>key</code>. </dd></dl>

</div>
</div>
<a id="a9291a6ab4fe0ad1346049a8f2feddeaa" name="a9291a6ab4fe0ad1346049a8f2feddeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9291a6ab4fe0ad1346049a8f2feddeaa">&#9670;&nbsp;</a></span>matrix_function_partition_eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EivalsType , typename Cluster &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_function_partition_eigenvalues </td>
          <td>(</td>
          <td class="paramtype">const EivalsType &amp;&#160;</td>
          <td class="paramname"><em>eivals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; Cluster &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition eigenvalues in clusters of ei'vals close to each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eivals</td><td>Eigenvalues </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">clusters</td><td>Resulting partition of eigenvalues</td></tr>
  </table>
  </dd>
</dl>
<p>The partition satisfies the following two properties: </p>
<h1><a class="anchor" id="autotoc_md0"></a>
Any eigenvalue in a certain cluster is at most matrix_function_separation() away from another eigenvalue</h1>
<p >in the same cluster. </p>
<h1><a class="anchor" id="autotoc_md1"></a>
The distance between two eigenvalues in different clusters is more than matrix_function_separation().</h1>
<p >The implementation follows Algorithm 4.1 in the paper of Davies and Higham. </p>

</div>
</div>
<a id="a59cacdc2f9b480da246258bc9399aa2c" name="a59cacdc2f9b480da246258bc9399aa2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cacdc2f9b480da246258bc9399aa2c">&#9670;&nbsp;</a></span>matrix_function_permute_schur()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_function_permute_schur </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permute Schur decomposition in U and T according to permutation. </p>

</div>
</div>
<a id="a9f7e5b9803071057e7ed4e887da4a1bb" name="a9f7e5b9803071057e7ed4e887da4a1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7e5b9803071057e7ed4e887da4a1bb">&#9670;&nbsp;</a></span>matrix_function_solve_triangular_sylvester()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType Eigen::internal::matrix_function_solve_triangular_sylvester </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a triangular Sylvester equation AX + XB = C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>the matrix A; should be square and upper triangular </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>the matrix B; should be square and upper triangular </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>the matrix C; should have correct size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution X.</dd></dl>
<p>If A is m-by-m and B is n-by-n, then both C and X are m-by-n. The (i,j)-th component of the Sylvester equation is </p><p class="formulaDsp">
\[
    \sum_{k=i}^m A_{ik} X_{kj} + \sum_{k=1}^j X_{ik} B_{kj} = C_{ij}.
\]
</p>
<p> This can be re-arranged to yield: </p><p class="formulaDsp">
\[
    X_{ij} = \frac{1}{A_{ii} + B_{jj}} \Bigl( C_{ij}
    - \sum_{k=i+1}^m A_{ik} X_{kj} - \sum_{k=1}^{j-1} X_{ik} B_{kj} \Bigr).
\]
</p>
<p> It is assumed that A and B are such that the numerator is never zero (otherwise the Sylvester equation does not have a unique solution). In that case, these equations can be evaluated in the order \( i=m,\ldots,1 \) and \( j=1,\ldots,n \). </p>

</div>
</div>
<a id="a1cb8d312c017f94570a52317fd1ece5f" name="a1cb8d312c017f94570a52317fd1ece5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb8d312c017f94570a52317fd1ece5f">&#9670;&nbsp;</a></span>matrix_log_compute_2x2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_log_compute_2x2 </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute logarithm of 2x2 triangular matrix. </p>

</div>
</div>
<a id="ac2de7acbbff34ec236ee5e9fdb2eee38" name="ac2de7acbbff34ec236ee5e9fdb2eee38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2de7acbbff34ec236ee5e9fdb2eee38">&#9670;&nbsp;</a></span>matrix_log_compute_big()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_log_compute_big </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute logarithm of triangular matrices with size &gt; 2. </p>
<p >This uses a inverse scale-and-square algorithm. </p>

</div>
</div>
<a id="a366cdd93d3035b0053cc8b3bff77f2a4" name="a366cdd93d3035b0053cc8b3bff77f2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366cdd93d3035b0053cc8b3bff77f2a4">&#9670;&nbsp;</a></span>matrix_log_compute_pade()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_log_compute_pade </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cdde7861546c148b2067fd94b3933f0" name="a7cdde7861546c148b2067fd94b3933f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdde7861546c148b2067fd94b3933f0">&#9670;&nbsp;</a></span>matrix_log_get_pade_degree() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Eigen::internal::matrix_log_get_pade_degree </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>normTminusI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0091d6d89ad60b1117bbb1b4b9901d0" name="ae0091d6d89ad60b1117bbb1b4b9901d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0091d6d89ad60b1117bbb1b4b9901d0">&#9670;&nbsp;</a></span>matrix_log_get_pade_degree() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Eigen::internal::matrix_log_get_pade_degree </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>normTminusI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6cb311dc4965edfa087bc35a9ee99ed" name="ab6cb311dc4965edfa087bc35a9ee99ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cb311dc4965edfa087bc35a9ee99ed">&#9670;&nbsp;</a></span>matrix_log_get_pade_degree() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Eigen::internal::matrix_log_get_pade_degree </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>normTminusI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab017c7f19f2a39bdb8e1ef75da19282f" name="ab017c7f19f2a39bdb8e1ef75da19282f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab017c7f19f2a39bdb8e1ef75da19282f">&#9670;&nbsp;</a></span>matrix_sqrt_quasi_triangular_1x1_off_diagonal_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_sqrt_quasi_triangular_1x1_off_diagonal_block </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>sqrtT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51428fd358b479e7f0b14efb4fea5932" name="a51428fd358b479e7f0b14efb4fea5932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51428fd358b479e7f0b14efb4fea5932">&#9670;&nbsp;</a></span>matrix_sqrt_quasi_triangular_1x2_off_diagonal_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_sqrt_quasi_triangular_1x2_off_diagonal_block </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>sqrtT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acde5a081fe6c25ef0ffc3d89bc59f117" name="acde5a081fe6c25ef0ffc3d89bc59f117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde5a081fe6c25ef0ffc3d89bc59f117">&#9670;&nbsp;</a></span>matrix_sqrt_quasi_triangular_2x1_off_diagonal_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_sqrt_quasi_triangular_2x1_off_diagonal_block </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>sqrtT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92f37da4b71409d05402a1475639314c" name="a92f37da4b71409d05402a1475639314c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f37da4b71409d05402a1475639314c">&#9670;&nbsp;</a></span>matrix_sqrt_quasi_triangular_2x2_diagonal_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_sqrt_quasi_triangular_2x2_diagonal_block </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>sqrtT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97eecfb57cb62e6e0b046e38e2ee4549" name="a97eecfb57cb62e6e0b046e38e2ee4549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97eecfb57cb62e6e0b046e38e2ee4549">&#9670;&nbsp;</a></span>matrix_sqrt_quasi_triangular_2x2_off_diagonal_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_sqrt_quasi_triangular_2x2_off_diagonal_block </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>sqrtT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e5c9733af465bc14851019818a5d2b3" name="a8e5c9733af465bc14851019818a5d2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5c9733af465bc14851019818a5d2b3">&#9670;&nbsp;</a></span>matrix_sqrt_quasi_triangular_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_sqrt_quasi_triangular_diagonal </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>sqrtT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95c0b49fec5ce44af43283d7f541d341" name="a95c0b49fec5ce44af43283d7f541d341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c0b49fec5ce44af43283d7f541d341">&#9670;&nbsp;</a></span>matrix_sqrt_quasi_triangular_off_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_sqrt_quasi_triangular_off_diagonal </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>sqrtT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a691211492c8b69df5c7391bd1de411c4" name="a691211492c8b69df5c7391bd1de411c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691211492c8b69df5c7391bd1de411c4">&#9670;&nbsp;</a></span>matrix_sqrt_quasi_triangular_solve_auxiliary_equation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_sqrt_quasi_triangular_solve_auxiliary_equation </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9727c15ffb97a40df226fce93e2628b3" name="a9727c15ffb97a40df226fce93e2628b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9727c15ffb97a40df226fce93e2628b3">&#9670;&nbsp;</a></span>stem_function_cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar Eigen::internal::stem_function_cos </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cosine (and its derivatives). </p>

</div>
</div>
<a id="aab7949e5c95ec574eff5c4229da36846" name="aab7949e5c95ec574eff5c4229da36846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7949e5c95ec574eff5c4229da36846">&#9670;&nbsp;</a></span>stem_function_cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar Eigen::internal::stem_function_cosh </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hyperbolic cosine (and its derivatives). </p>

</div>
</div>
<a id="a0e7bafccf7fa66d965ab6c59444a39c3" name="a0e7bafccf7fa66d965ab6c59444a39c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7bafccf7fa66d965ab6c59444a39c3">&#9670;&nbsp;</a></span>stem_function_exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar Eigen::internal::stem_function_exp </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The exponential function (and its derivatives). </p>

</div>
</div>
<a id="a297dc38f5c9b80e2a1da7dcf2a453c90" name="a297dc38f5c9b80e2a1da7dcf2a453c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297dc38f5c9b80e2a1da7dcf2a453c90">&#9670;&nbsp;</a></span>stem_function_sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar Eigen::internal::stem_function_sin </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sine (and its derivatives). </p>

</div>
</div>
<a id="ab2855d150c9eebb8ed6cb63a292dda0d" name="ab2855d150c9eebb8ed6cb63a292dda0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2855d150c9eebb8ed6cb63a292dda0d">&#9670;&nbsp;</a></span>stem_function_sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar Eigen::internal::stem_function_sinh </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hyperbolic sine (and its derivatives). </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a83aececb2dc32d30c1aa55f9aa5532d9" name="a83aececb2dc32d30c1aa55f9aa5532d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83aececb2dc32d30c1aa55f9aa5532d9">&#9670;&nbsp;</a></span>matrix_function_separation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float Eigen::internal::matrix_function_separation = 0.1f</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum distance allowed between eigenvalues to be considered "close". </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_eigen.html">Eigen</a></li><li class="navelem"><a class="el" href="namespace_eigen_1_1internal.html">internal</a></li>
    <li class="footer">Generated on Wed Mar 13 2024 05:20:43 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
