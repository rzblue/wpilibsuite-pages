<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: sleipnir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.0.0-alpha-1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacesleipnir.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sleipnir Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesleipnir_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_equality_constraints.html">EqualityConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of equality constraints of the form cₑ(x) = 0.  <a href="structsleipnir_1_1_equality_constraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of std::function_ref, a lightweight non-owning reference to a callable.  <a href="classsleipnir_1_1function__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1function__ref_3_01_r_07_args_8_8_8_08_4.html">function_ref&lt; R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_gradient.html">Gradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class calculates the gradient of a a variable with respect to a vector of variables.  <a href="classsleipnir_1_1_gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_hessian.html">Hessian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class calculates the <a class="el" href="classsleipnir_1_1_hessian.html" title="This class calculates the Hessian of a variable with respect to a vector of variables.">Hessian</a> of a variable with respect to a vector of variables.  <a href="classsleipnir_1_1_hessian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of inequality constraints of the form cᵢ(x) ≥ 0.  <a href="structsleipnir_1_1_inequality_constraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom intrusive shared pointer implementation without thread synchronization overhead.  <a href="classsleipnir_1_1_intrusive_shared_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_jacobian.html">Jacobian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class calculates the <a class="el" href="classsleipnir_1_1_jacobian.html" title="This class calculates the Jacobian of a vector of variables with respect to a vector of variables.">Jacobian</a> of a vector of variables with respect to a vector of variables.  <a href="classsleipnir_1_1_jacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_multistart_result.html">MultistartResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a multistart solve.  <a href="structsleipnir_1_1_multistart_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_o_c_p_solver.html">OCPSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows the user to pose and solve a constrained optimal control problem (OCP) in a variety of ways.  <a href="classsleipnir_1_1_o_c_p_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html">OptimizationProblem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows the user to pose a constrained nonlinear optimization problem in natural mathematical notation and solve it.  <a href="classsleipnir_1_1_optimization_problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_pool_allocator.html">PoolAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an allocator for the pool resource.  <a href="classsleipnir_1_1_pool_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_pool_resource.html">PoolResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a pool memory resource.  <a href="classsleipnir_1_1_pool_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_profiler.html">Profiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the number of profiler measurements (start/stop pairs) and the average duration between each start and stop call.  <a href="classsleipnir_1_1_profiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_solver_config.html">SolverConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver configuration.  <a href="structsleipnir_1_1_solver_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_solver_iteration_info.html">SolverIterationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver iteration information exposed to a user callback.  <a href="structsleipnir_1_1_solver_iteration_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_solver_status.html">SolverStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value of <a class="el" href="classsleipnir_1_1_optimization_problem.html#a9b9e483026fddcd34a110790916e8f92" title="Solve the optimization problem.">OptimizationProblem::Solve()</a> containing the cost function and constraint types and solver's exit condition.  <a href="structsleipnir_1_1_solver_status.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An autodiff variable pointing to an expression node.  <a href="classsleipnir_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_variable_block.html">VariableBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A submatrix of autodiff variables with reference semantics.  <a href="classsleipnir_1_1_variable_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of autodiff variables.  <a href="classsleipnir_1_1_variable_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsleipnir_1_1_scalar_like.html">ScalarLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsleipnir_1_1_sleipnir_matrix_like.html">SleipnirMatrixLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsleipnir_1_1_eigen_matrix_like.html">EigenMatrixLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsleipnir_1_1_eigen_solver.html">EigenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsleipnir_1_1_matrix_like.html">MatrixLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae005da56b85caa9af6fd6fffafcc2005"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ae005da56b85caa9af6fd6fffafcc2005">DynamicsFunction</a> = <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>(const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;)&gt;</td></tr>
<tr class="memdesc:ae005da56b85caa9af6fd6fffafcc2005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function representing an explicit or implicit ODE, or a discrete state transition function.  <a href="namespacesleipnir.html#ae005da56b85caa9af6fd6fffafcc2005">More...</a><br /></td></tr>
<tr class="separator:ae005da56b85caa9af6fd6fffafcc2005"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a63018833d7a0635f244a22539dfc76d1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a63018833d7a0635f244a22539dfc76d1">ExpressionType</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacesleipnir.html#a63018833d7a0635f244a22539dfc76d1a35c3ace1970663a16e5c65baa5941b13">kNone</a>
, <a class="el" href="namespacesleipnir.html#a63018833d7a0635f244a22539dfc76d1a043b62a71551e8b511099802b2b59a98">kConstant</a>
, <a class="el" href="namespacesleipnir.html#a63018833d7a0635f244a22539dfc76d1aac97f0008bcf7c7fe4f2ff94160e1385">kLinear</a>
, <a class="el" href="namespacesleipnir.html#a63018833d7a0635f244a22539dfc76d1af841876fc54bbdba16a4ae2e0d070714">kQuadratic</a>
, <br />
&#160;&#160;<a class="el" href="namespacesleipnir.html#a63018833d7a0635f244a22539dfc76d1aca517032c6fda1fd3881f922c50ed8d6">kNonlinear</a>
<br />
 }</td></tr>
<tr class="memdesc:a63018833d7a0635f244a22539dfc76d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression type.  <a href="namespacesleipnir.html#a63018833d7a0635f244a22539dfc76d1">More...</a><br /></td></tr>
<tr class="separator:a63018833d7a0635f244a22539dfc76d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6ff477fca07d31231aade7ce57207a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207a">TranscriptionMethod</a> : uint8_t { <a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207aae09070d9a1cb5eaf8c431ff130d77254">kDirectTranscription</a>
, <a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207aaeadf163719d8eaba16f306e4623348ae">kDirectCollocation</a>
, <a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207aa6d0c9c617bab8979ca91133854abe778">kSingleShooting</a>
 }</td></tr>
<tr class="memdesc:a7b6ff477fca07d31231aade7ce57207a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum describing an OCP transcription method.  <a href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207a">More...</a><br /></td></tr>
<tr class="separator:a7b6ff477fca07d31231aade7ce57207a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e60fa99ee023884ea7a163a67169f7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7">DynamicsType</a> : uint8_t { <a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7a6976d4824b9f5192d274a69163d67423">kExplicitODE</a>
, <a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7a7095b968071a21b3995448cd36a11cef">kDiscrete</a>
 }</td></tr>
<tr class="memdesc:a38e60fa99ee023884ea7a163a67169f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum describing a type of system dynamics constraints.  <a href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7">More...</a><br /></td></tr>
<tr class="separator:a38e60fa99ee023884ea7a163a67169f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c8390ba2ad034b958630d8b7d962b4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4">TimestepMethod</a> : uint8_t { <a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4a826888a09763de7e2a9f60eb85d88b24">kFixed</a>
, <a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4afb751f6ee1af15e773242f2accd2dbff">kVariable</a>
, <a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4a0b8eddab15f53a79424adf236397d84b">kVariableSingle</a>
 }</td></tr>
<tr class="memdesc:aa0c8390ba2ad034b958630d8b7d962b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum describing the type of system timestep.  <a href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4">More...</a><br /></td></tr>
<tr class="separator:aa0c8390ba2ad034b958630d8b7d962b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c3ac8825940144e76ed87f719b68d4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4">SolverExitCondition</a> : int8_t { <br />
&#160;&#160;<a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4a8c632159fa131f09d04f94e3cbcd8782">kSuccess</a> = 0
, <a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4a9545092cb61579e7f46a975d689b1bb8">kSolvedToAcceptableTolerance</a> = 1
, <a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4ad4c976257a619492860b8840abbcaf42">kCallbackRequestedStop</a> = 2
, <a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4aa80022963c2851dfd91949197cac8966">kTooFewDOFs</a> = -1
, <br />
&#160;&#160;<a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4a53ed66e6fa1f49615898ecce46fdbcb3">kLocallyInfeasible</a> = -2
, <a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4a23de0db053f48655155d173a39c62892">kFeasibilityRestorationFailed</a> = -3
, <a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4a08b5756e830054c09726f2d6ddfc98e4">kNonfiniteInitialCostOrConstraints</a> = -4
, <a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4abbefad5cbd24b04a4e4fb6bcae075c67">kDivergingIterates</a> = -5
, <br />
&#160;&#160;<a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4aad44d676f2d7acde9d736d83919b077f">kMaxIterationsExceeded</a> = -6
, <a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4a7f27861ff1d3f550c6aa77150d7edabd">kTimeout</a> = -7
<br />
 }</td></tr>
<tr class="memdesc:a79c3ac8825940144e76ed87f719b68d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver exit condition.  <a href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4">More...</a><br /></td></tr>
<tr class="separator:a79c3ac8825940144e76ed87f719b68d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0501d2b2d374051aada53be41ea076d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a0501d2b2d374051aada53be41ea076d7">CwiseReduce</a> (const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;lhs, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;rhs, <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>(const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;)&gt; binaryOp)</td></tr>
<tr class="memdesc:a0501d2b2d374051aada53be41ea076d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a coefficient-wise reduce operation to two matrices.  <a href="namespacesleipnir.html#a0501d2b2d374051aada53be41ea076d7">More...</a><br /></td></tr>
<tr class="separator:a0501d2b2d374051aada53be41ea076d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b87e3e8a405ae19e2f83758cd190d51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a4b87e3e8a405ae19e2f83758cd190d51">Block</a> (std::initializer_list&lt; std::initializer_list&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt; list)</td></tr>
<tr class="memdesc:a4b87e3e8a405ae19e2f83758cd190d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble a <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks.  <a href="namespacesleipnir.html#a4b87e3e8a405ae19e2f83758cd190d51">More...</a><br /></td></tr>
<tr class="separator:a4b87e3e8a405ae19e2f83758cd190d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad832e947d36c86a6e99381d1787137a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ad832e947d36c86a6e99381d1787137a6">Block</a> (std::vector&lt; std::vector&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt; list)</td></tr>
<tr class="memdesc:ad832e947d36c86a6e99381d1787137a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble a <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks.  <a href="namespacesleipnir.html#ad832e947d36c86a6e99381d1787137a6">More...</a><br /></td></tr>
<tr class="separator:ad832e947d36c86a6e99381d1787137a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069c0c391e426f231f1ed5e28288fbe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a069c0c391e426f231f1ed5e28288fbe9">Solve</a> (const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;A, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a069c0c391e426f231f1ed5e28288fbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> equation AX = B for X.  <a href="namespacesleipnir.html#a069c0c391e426f231f1ed5e28288fbe9">More...</a><br /></td></tr>
<tr class="separator:a069c0c391e426f231f1ed5e28288fbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcb7ba159c1d2c57e30301122d332ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a8bcb7ba159c1d2c57e30301122d332ce">abs</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a8bcb7ba159c1d2c57e30301122d332ce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a8bcb7ba159c1d2c57e30301122d332ce" title="std::abs() for Variables.">std::abs()</a> for Variables.  <a href="namespacesleipnir.html#a8bcb7ba159c1d2c57e30301122d332ce">More...</a><br /></td></tr>
<tr class="separator:a8bcb7ba159c1d2c57e30301122d332ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93830608ececa1b6655278a6c405de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ad93830608ececa1b6655278a6c405de7">acos</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:ad93830608ececa1b6655278a6c405de7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#ad93830608ececa1b6655278a6c405de7" title="std::acos() for Variables.">std::acos()</a> for Variables.  <a href="namespacesleipnir.html#ad93830608ececa1b6655278a6c405de7">More...</a><br /></td></tr>
<tr class="separator:ad93830608ececa1b6655278a6c405de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33bb89eba6454138b7cd58a64054a7c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a33bb89eba6454138b7cd58a64054a7c8">asin</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a33bb89eba6454138b7cd58a64054a7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a33bb89eba6454138b7cd58a64054a7c8" title="std::asin() for Variables.">std::asin()</a> for Variables.  <a href="namespacesleipnir.html#a33bb89eba6454138b7cd58a64054a7c8">More...</a><br /></td></tr>
<tr class="separator:a33bb89eba6454138b7cd58a64054a7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f210b7e74658edaf15731391a5cc30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#aa0f210b7e74658edaf15731391a5cc30">atan</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:aa0f210b7e74658edaf15731391a5cc30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#aa0f210b7e74658edaf15731391a5cc30" title="std::atan() for Variables.">std::atan()</a> for Variables.  <a href="namespacesleipnir.html#aa0f210b7e74658edaf15731391a5cc30">More...</a><br /></td></tr>
<tr class="separator:aa0f210b7e74658edaf15731391a5cc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630df7b189e4d16bff3726fe721d6152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a630df7b189e4d16bff3726fe721d6152">atan2</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;y, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a630df7b189e4d16bff3726fe721d6152"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a630df7b189e4d16bff3726fe721d6152" title="std::atan2() for Variables.">std::atan2()</a> for Variables.  <a href="namespacesleipnir.html#a630df7b189e4d16bff3726fe721d6152">More...</a><br /></td></tr>
<tr class="separator:a630df7b189e4d16bff3726fe721d6152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ae23d1e0093b86bc44621c4c49c0ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#aa1ae23d1e0093b86bc44621c4c49c0ea">cos</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:aa1ae23d1e0093b86bc44621c4c49c0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#aa1ae23d1e0093b86bc44621c4c49c0ea" title="std::cos() for Variables.">std::cos()</a> for Variables.  <a href="namespacesleipnir.html#aa1ae23d1e0093b86bc44621c4c49c0ea">More...</a><br /></td></tr>
<tr class="separator:aa1ae23d1e0093b86bc44621c4c49c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340047f0b6fb9d03a760f5804e2ddf07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a340047f0b6fb9d03a760f5804e2ddf07">cosh</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a340047f0b6fb9d03a760f5804e2ddf07"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a340047f0b6fb9d03a760f5804e2ddf07" title="std::cosh() for Variables.">std::cosh()</a> for Variables.  <a href="namespacesleipnir.html#a340047f0b6fb9d03a760f5804e2ddf07">More...</a><br /></td></tr>
<tr class="separator:a340047f0b6fb9d03a760f5804e2ddf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a197c5c59bf157df1f414d7c2ccfe3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a6a197c5c59bf157df1f414d7c2ccfe3b">erf</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a6a197c5c59bf157df1f414d7c2ccfe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a6a197c5c59bf157df1f414d7c2ccfe3b" title="std::erf() for Variables.">std::erf()</a> for Variables.  <a href="namespacesleipnir.html#a6a197c5c59bf157df1f414d7c2ccfe3b">More...</a><br /></td></tr>
<tr class="separator:a6a197c5c59bf157df1f414d7c2ccfe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f351c4c585bd5b7962a89f2e2a1155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ac3f351c4c585bd5b7962a89f2e2a1155">exp</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:ac3f351c4c585bd5b7962a89f2e2a1155"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::exp() for Variables.  <a href="namespacesleipnir.html#ac3f351c4c585bd5b7962a89f2e2a1155">More...</a><br /></td></tr>
<tr class="separator:ac3f351c4c585bd5b7962a89f2e2a1155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6e8e37214d28794471c8b01409a128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a9f6e8e37214d28794471c8b01409a128">hypot</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;y)</td></tr>
<tr class="memdesc:a9f6e8e37214d28794471c8b01409a128"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a75aa3a7748057d8c986042ad330758e4" title="std::hypot() for Variables.">std::hypot()</a> for Variables.  <a href="namespacesleipnir.html#a9f6e8e37214d28794471c8b01409a128">More...</a><br /></td></tr>
<tr class="separator:a9f6e8e37214d28794471c8b01409a128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f18573caf44bef6642332ad98ff4f9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a9f18573caf44bef6642332ad98ff4f9a">pow</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;base, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;power)</td></tr>
<tr class="memdesc:a9f18573caf44bef6642332ad98ff4f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a9f18573caf44bef6642332ad98ff4f9a" title="std::pow() for Variables.">std::pow()</a> for Variables.  <a href="namespacesleipnir.html#a9f18573caf44bef6642332ad98ff4f9a">More...</a><br /></td></tr>
<tr class="separator:a9f18573caf44bef6642332ad98ff4f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c000918d7d254f363e71def1a77cce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a9c000918d7d254f363e71def1a77cce9">log</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a9c000918d7d254f363e71def1a77cce9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a9c000918d7d254f363e71def1a77cce9" title="std::log() for Variables.">std::log()</a> for Variables.  <a href="namespacesleipnir.html#a9c000918d7d254f363e71def1a77cce9">More...</a><br /></td></tr>
<tr class="separator:a9c000918d7d254f363e71def1a77cce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f6511dbade8eb4e8486c5718015ddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ad5f6511dbade8eb4e8486c5718015ddb">log10</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:ad5f6511dbade8eb4e8486c5718015ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#ad5f6511dbade8eb4e8486c5718015ddb" title="std::log10() for Variables.">std::log10()</a> for Variables.  <a href="namespacesleipnir.html#ad5f6511dbade8eb4e8486c5718015ddb">More...</a><br /></td></tr>
<tr class="separator:ad5f6511dbade8eb4e8486c5718015ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ee3b7626080eaba8e8b65467bf23b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a36ee3b7626080eaba8e8b65467bf23b2">sign</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a36ee3b7626080eaba8e8b65467bf23b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a36ee3b7626080eaba8e8b65467bf23b2" title="sign() for Variables.">sign()</a> for Variables.  <a href="namespacesleipnir.html#a36ee3b7626080eaba8e8b65467bf23b2">More...</a><br /></td></tr>
<tr class="separator:a36ee3b7626080eaba8e8b65467bf23b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2f17480dc7667bca2b8f027a9ff1f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a1a2f17480dc7667bca2b8f027a9ff1f1">sin</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a1a2f17480dc7667bca2b8f027a9ff1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a1a2f17480dc7667bca2b8f027a9ff1f1" title="std::sin() for Variables.">std::sin()</a> for Variables.  <a href="namespacesleipnir.html#a1a2f17480dc7667bca2b8f027a9ff1f1">More...</a><br /></td></tr>
<tr class="separator:a1a2f17480dc7667bca2b8f027a9ff1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdce37409d87f0aa0d5c124ff555a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a7fdce37409d87f0aa0d5c124ff555a58">sinh</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a7fdce37409d87f0aa0d5c124ff555a58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a7fdce37409d87f0aa0d5c124ff555a58" title="std::sinh() for Variables.">std::sinh()</a> for Variables.  <a href="namespacesleipnir.html#a7fdce37409d87f0aa0d5c124ff555a58">More...</a><br /></td></tr>
<tr class="separator:a7fdce37409d87f0aa0d5c124ff555a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab400367eb603c4220c814bde2ef91c5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ab400367eb603c4220c814bde2ef91c5f">sqrt</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:ab400367eb603c4220c814bde2ef91c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#ab400367eb603c4220c814bde2ef91c5f" title="std::sqrt() for Variables.">std::sqrt()</a> for Variables.  <a href="namespacesleipnir.html#ab400367eb603c4220c814bde2ef91c5f">More...</a><br /></td></tr>
<tr class="separator:ab400367eb603c4220c814bde2ef91c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2190666baa579f39848387efb37a228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ab2190666baa579f39848387efb37a228">tan</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:ab2190666baa579f39848387efb37a228"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::tan() for Variables.  <a href="namespacesleipnir.html#ab2190666baa579f39848387efb37a228">More...</a><br /></td></tr>
<tr class="separator:ab2190666baa579f39848387efb37a228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241833c33e81b406cfbfc069342c339a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a241833c33e81b406cfbfc069342c339a">tanh</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a241833c33e81b406cfbfc069342c339a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a241833c33e81b406cfbfc069342c339a" title="std::tanh() for Variables.">std::tanh()</a> for Variables.  <a href="namespacesleipnir.html#a241833c33e81b406cfbfc069342c339a">More...</a><br /></td></tr>
<tr class="separator:a241833c33e81b406cfbfc069342c339a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa3a7748057d8c986042ad330758e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a75aa3a7748057d8c986042ad330758e4">hypot</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;y, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;z)</td></tr>
<tr class="memdesc:a75aa3a7748057d8c986042ad330758e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacesleipnir.html#a75aa3a7748057d8c986042ad330758e4" title="std::hypot() for Variables.">std::hypot()</a> for Variables.  <a href="namespacesleipnir.html#a75aa3a7748057d8c986042ad330758e4">More...</a><br /></td></tr>
<tr class="separator:a75aa3a7748057d8c986042ad330758e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e055561e1b55a4f4efdfc1dcb06ff8"><td class="memTemplParams" colspan="2">template&lt;typename F , typename State , typename Input , typename Time &gt; </td></tr>
<tr class="memitem:ac3e055561e1b55a4f4efdfc1dcb06ff8"><td class="memTemplItemLeft" align="right" valign="top">State&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ac3e055561e1b55a4f4efdfc1dcb06ff8">RK4</a> (F &amp;&amp;f, State x, Input u, Time t0, Time dt)</td></tr>
<tr class="memdesc:ac3e055561e1b55a4f4efdfc1dcb06ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 4th order Runge-Kutta integration of dx/dt = f(t, x, u) for dt.  <a href="namespacesleipnir.html#ac3e055561e1b55a4f4efdfc1dcb06ff8">More...</a><br /></td></tr>
<tr class="separator:ac3e055561e1b55a4f4efdfc1dcb06ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e2d9ee285c6a874e470ddfe192bd50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_pool_resource.html">PoolResource</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ab1e2d9ee285c6a874e470ddfe192bd50">GlobalPoolResource</a> ()</td></tr>
<tr class="memdesc:ab1e2d9ee285c6a874e470ddfe192bd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global pool memory resource.  <a href="namespacesleipnir.html#ab1e2d9ee285c6a874e470ddfe192bd50">More...</a><br /></td></tr>
<tr class="separator:ab1e2d9ee285c6a874e470ddfe192bd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c3a2b931fa1c5fccccd2740e9ef94d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a75c3a2b931fa1c5fccccd2740e9ef94d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_pool_allocator.html">PoolAllocator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a75c3a2b931fa1c5fccccd2740e9ef94d">GlobalPoolAllocator</a> ()</td></tr>
<tr class="memdesc:a75c3a2b931fa1c5fccccd2740e9ef94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an allocator for a global pool memory resource.  <a href="namespacesleipnir.html#a75c3a2b931fa1c5fccccd2740e9ef94d">More...</a><br /></td></tr>
<tr class="separator:a75c3a2b931fa1c5fccccd2740e9ef94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7912f1f51db075b3acf93320281326f7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a7912f1f51db075b3acf93320281326f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a7912f1f51db075b3acf93320281326f7">MakeIntrusiveShared</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7912f1f51db075b3acf93320281326f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T and wraps it in an intrusive shared pointer using args as the parameter list for the constructor of T.  <a href="namespacesleipnir.html#a7912f1f51db075b3acf93320281326f7">More...</a><br /></td></tr>
<tr class="separator:a7912f1f51db075b3acf93320281326f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080968b3ea028d444bc29448bfa29e97"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc , typename... Args&gt; </td></tr>
<tr class="memitem:a080968b3ea028d444bc29448bfa29e97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a080968b3ea028d444bc29448bfa29e97">AllocateIntrusiveShared</a> (Alloc alloc, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a080968b3ea028d444bc29448bfa29e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T and wraps it in an intrusive shared pointer using alloc as the storage allocator of T and args as the parameter list for the constructor of T.  <a href="namespacesleipnir.html#a080968b3ea028d444bc29448bfa29e97">More...</a><br /></td></tr>
<tr class="separator:a080968b3ea028d444bc29448bfa29e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9442c1a3c76b61a27bfc46bed4a0cc5b"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a9442c1a3c76b61a27bfc46bed4a0cc5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a9442c1a3c76b61a27bfc46bed4a0cc5b">print</a> (<a class="el" href="core_8h.html#a56a828fb91283babdb0eef8e0d9010cb">fmt::format_string</a>&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9442c1a3c76b61a27bfc46bed4a0cc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around <a class="el" href="namespacesleipnir.html#a70d0e712de46cfa1e7a9456b0519257e" title="Wrapper around fmt::print() that squelches write failure exceptions.">fmt::print()</a> that squelches write failure exceptions.  <a href="namespacesleipnir.html#a9442c1a3c76b61a27bfc46bed4a0cc5b">More...</a><br /></td></tr>
<tr class="separator:a9442c1a3c76b61a27bfc46bed4a0cc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d0e712de46cfa1e7a9456b0519257e"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a70d0e712de46cfa1e7a9456b0519257e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a70d0e712de46cfa1e7a9456b0519257e">print</a> (std::FILE *f, <a class="el" href="core_8h.html#a56a828fb91283babdb0eef8e0d9010cb">fmt::format_string</a>&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a70d0e712de46cfa1e7a9456b0519257e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around <a class="el" href="namespacesleipnir.html#a70d0e712de46cfa1e7a9456b0519257e" title="Wrapper around fmt::print() that squelches write failure exceptions.">fmt::print()</a> that squelches write failure exceptions.  <a href="namespacesleipnir.html#a70d0e712de46cfa1e7a9456b0519257e">More...</a><br /></td></tr>
<tr class="separator:a70d0e712de46cfa1e7a9456b0519257e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0758fba396daf7bac66206f04df32b31"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a0758fba396daf7bac66206f04df32b31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a0758fba396daf7bac66206f04df32b31">println</a> (<a class="el" href="core_8h.html#a56a828fb91283babdb0eef8e0d9010cb">fmt::format_string</a>&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0758fba396daf7bac66206f04df32b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around <a class="el" href="namespacesleipnir.html#a225e73b7f33254984c4bd99107c5e564" title="Wrapper around fmt::println() that squelches write failure exceptions.">fmt::println()</a> that squelches write failure exceptions.  <a href="namespacesleipnir.html#a0758fba396daf7bac66206f04df32b31">More...</a><br /></td></tr>
<tr class="separator:a0758fba396daf7bac66206f04df32b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225e73b7f33254984c4bd99107c5e564"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a225e73b7f33254984c4bd99107c5e564"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a225e73b7f33254984c4bd99107c5e564">println</a> (std::FILE *f, <a class="el" href="core_8h.html#a56a828fb91283babdb0eef8e0d9010cb">fmt::format_string</a>&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a225e73b7f33254984c4bd99107c5e564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around <a class="el" href="namespacesleipnir.html#a225e73b7f33254984c4bd99107c5e564" title="Wrapper around fmt::println() that squelches write failure exceptions.">fmt::println()</a> that squelches write failure exceptions.  <a href="namespacesleipnir.html#a225e73b7f33254984c4bd99107c5e564">More...</a><br /></td></tr>
<tr class="separator:a225e73b7f33254984c4bd99107c5e564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7317a14ecb6fd2609fc40a0ea2577cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a7317a14ecb6fd2609fc40a0ea2577cc1">Spy</a> (std::ostream &amp;<a class="el" href="_third_party_notices_8txt.html#a54c3aaa43358b77e4f57f4f72cbe56c6">file</a>, const Eigen::SparseMatrix&lt; double &gt; &amp;mat)</td></tr>
<tr class="memdesc:a7317a14ecb6fd2609fc40a0ea2577cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the sparsity pattern of a sparse matrix to a file.  <a href="namespacesleipnir.html#a7317a14ecb6fd2609fc40a0ea2577cc1">More...</a><br /></td></tr>
<tr class="separator:a7317a14ecb6fd2609fc40a0ea2577cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c613f4826d87e80d9ee015cc56a5ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a89c613f4826d87e80d9ee015cc56a5ff">Spy</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> filename, const Eigen::SparseMatrix&lt; double &gt; &amp;mat)</td></tr>
<tr class="memdesc:a89c613f4826d87e80d9ee015cc56a5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the sparsity pattern of a sparse matrix to a file.  <a href="namespacesleipnir.html#a89c613f4826d87e80d9ee015cc56a5ff">More...</a><br /></td></tr>
<tr class="separator:a89c613f4826d87e80d9ee015cc56a5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b18604d3561d5bacf5281f1e6cf1993"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a7b18604d3561d5bacf5281f1e6cf1993"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a7b18604d3561d5bacf5281f1e6cf1993">swap</a> (<a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;lhs, <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a7b18604d3561d5bacf5281f1e6cf1993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the referred callables of <code>lhs</code> and <code>rhs</code>.  <a href="namespacesleipnir.html#a7b18604d3561d5bacf5281f1e6cf1993">More...</a><br /></td></tr>
<tr class="separator:a7b18604d3561d5bacf5281f1e6cf1993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed489757f97c9302617cb499226741c2"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:aed489757f97c9302617cb499226741c2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#aed489757f97c9302617cb499226741c2">function_ref</a> (R(*)(Args...)) -&gt; <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt;</td></tr>
<tr class="separator:aed489757f97c9302617cb499226741c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5505c6a23325ef4c196f9de5a694504"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:af5505c6a23325ef4c196f9de5a694504"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_small_vector.html">wpi::SmallVector</a>&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#af5505c6a23325ef4c196f9de5a694504">MakeConstraints</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:af5505c6a23325ef4c196f9de5a694504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a list of constraints.  <a href="namespacesleipnir.html#af5505c6a23325ef4c196f9de5a694504">More...</a><br /></td></tr>
<tr class="separator:af5505c6a23325ef4c196f9de5a694504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cac593a1dd030744b85cbe3d0e7da6"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:a58cac593a1dd030744b85cbe3d0e7da6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_equality_constraints.html">EqualityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a58cac593a1dd030744b85cbe3d0e7da6">operator==</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a58cac593a1dd030744b85cbe3d0e7da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator that returns an equality constraint for two Variables.  <a href="namespacesleipnir.html#a58cac593a1dd030744b85cbe3d0e7da6">More...</a><br /></td></tr>
<tr class="separator:a58cac593a1dd030744b85cbe3d0e7da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5f8232b7a7dfbd13239455ef47da5b"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:add5f8232b7a7dfbd13239455ef47da5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#add5f8232b7a7dfbd13239455ef47da5b">operator&lt;</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:add5f8232b7a7dfbd13239455ef47da5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison operator that returns an inequality constraint for two Variables.  <a href="namespacesleipnir.html#add5f8232b7a7dfbd13239455ef47da5b">More...</a><br /></td></tr>
<tr class="separator:add5f8232b7a7dfbd13239455ef47da5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d6a0d536d82302d3e3c29786e53219"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:a22d6a0d536d82302d3e3c29786e53219"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a22d6a0d536d82302d3e3c29786e53219">operator&lt;=</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a22d6a0d536d82302d3e3c29786e53219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than-or-equal-to comparison operator that returns an inequality constraint for two Variables.  <a href="namespacesleipnir.html#a22d6a0d536d82302d3e3c29786e53219">More...</a><br /></td></tr>
<tr class="separator:a22d6a0d536d82302d3e3c29786e53219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eb85f8960aa6b9efc40aabb9b1a2fa"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:ab2eb85f8960aa6b9efc40aabb9b1a2fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ab2eb85f8960aa6b9efc40aabb9b1a2fa">operator&gt;</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ab2eb85f8960aa6b9efc40aabb9b1a2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison operator that returns an inequality constraint for two Variables.  <a href="namespacesleipnir.html#ab2eb85f8960aa6b9efc40aabb9b1a2fa">More...</a><br /></td></tr>
<tr class="separator:ab2eb85f8960aa6b9efc40aabb9b1a2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababe98061e7c0f7d6e1334457af169ac"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:ababe98061e7c0f7d6e1334457af169ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ababe98061e7c0f7d6e1334457af169ac">operator&gt;=</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ababe98061e7c0f7d6e1334457af169ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than-or-equal-to comparison operator that returns an inequality constraint for two Variables.  <a href="namespacesleipnir.html#ababe98061e7c0f7d6e1334457af169ac">More...</a><br /></td></tr>
<tr class="separator:ababe98061e7c0f7d6e1334457af169ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a4065c9b3ad44d3d1a77f6fa9600ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a55a4065c9b3ad44d3d1a77f6fa9600ee">ToMessage</a> (const <a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4">SolverExitCondition</a> &amp;exitCondition)</td></tr>
<tr class="memdesc:a55a4065c9b3ad44d3d1a77f6fa9600ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns user-readable message corresponding to the exit condition.  <a href="namespacesleipnir.html#a55a4065c9b3ad44d3d1a77f6fa9600ee">More...</a><br /></td></tr>
<tr class="separator:a55a4065c9b3ad44d3d1a77f6fa9600ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f27c3603b711f7ba34eac53651f907"><td class="memTemplParams" colspan="2">template&lt;typename DecisionVariables &gt; </td></tr>
<tr class="memitem:a68f27c3603b711f7ba34eac53651f907"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a68f27c3603b711f7ba34eac53651f907">Multistart</a> (<a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="structsleipnir_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt;(const DecisionVariables &amp;)&gt; solve, std::span&lt; const DecisionVariables &gt; initialGuesses)</td></tr>
<tr class="memdesc:a68f27c3603b711f7ba34eac53651f907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization problem from different starting points in parallel, then returns the solution with the lowest cost.  <a href="namespacesleipnir.html#a68f27c3603b711f7ba34eac53651f907">More...</a><br /></td></tr>
<tr class="separator:a68f27c3603b711f7ba34eac53651f907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7f81173d77cc67455e1c09391e32ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a5b7f81173d77cc67455e1c09391e32ff">InteriorPoint</a> (std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt; decisionVariables, std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt; equalityConstraints, std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt; inequalityConstraints, <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;f, <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; bool(const <a class="el" href="structsleipnir_1_1_solver_iteration_info.html">SolverIterationInfo</a> &amp;)&gt; callback, const <a class="el" href="structsleipnir_1_1_solver_config.html">SolverConfig</a> &amp;config, bool feasibilityRestoration, Eigen::VectorXd &amp;x, Eigen::VectorXd &amp;s, <a class="el" href="structsleipnir_1_1_solver_status.html">SolverStatus</a> *status)</td></tr>
<tr class="memdesc:a5b7f81173d77cc67455e1c09391e32ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the optimal solution to a nonlinear program using the interior-point method.  <a href="namespacesleipnir.html#a5b7f81173d77cc67455e1c09391e32ff">More...</a><br /></td></tr>
<tr class="separator:a5b7f81173d77cc67455e1c09391e32ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a703d7cfeaa4b7bfabb6c20675a7e9055"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#a703d7cfeaa4b7bfabb6c20675a7e9055">Hessian</a></td></tr>
<tr class="separator:a703d7cfeaa4b7bfabb6c20675a7e9055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad566a82c0d33a39db1e2398075083bd8"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir.html#ad566a82c0d33a39db1e2398075083bd8">Jacobian</a></td></tr>
<tr class="separator:ad566a82c0d33a39db1e2398075083bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae005da56b85caa9af6fd6fffafcc2005" name="ae005da56b85caa9af6fd6fffafcc2005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae005da56b85caa9af6fd6fffafcc2005">&#9670;&nbsp;</a></span>DynamicsFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesleipnir.html#ae005da56b85caa9af6fd6fffafcc2005">sleipnir::DynamicsFunction</a> = typedef <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt;<a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>(const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&amp;, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&amp;, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&amp;, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function representing an explicit or implicit ODE, or a discrete state transition function. </p>
<ul>
<li>Explicit: dx/dt = f(t, x, u, *)</li>
<li>Implicit: f(t, [x dx/dt]', u, *) = 0</li>
<li>State transition: xₖ₊₁ = f(t, xₖ, uₖ, dt) </li>
</ul>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a38e60fa99ee023884ea7a163a67169f7" name="a38e60fa99ee023884ea7a163a67169f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e60fa99ee023884ea7a163a67169f7">&#9670;&nbsp;</a></span>DynamicsType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7">sleipnir::DynamicsType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum describing a type of system dynamics constraints. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a38e60fa99ee023884ea7a163a67169f7a6976d4824b9f5192d274a69163d67423" name="a38e60fa99ee023884ea7a163a67169f7a6976d4824b9f5192d274a69163d67423"></a>kExplicitODE&#160;</td><td class="fielddoc"><p >The dynamics are a function in the form dx/dt = f(t, x, u). </p>
</td></tr>
<tr><td class="fieldname"><a id="a38e60fa99ee023884ea7a163a67169f7a7095b968071a21b3995448cd36a11cef" name="a38e60fa99ee023884ea7a163a67169f7a7095b968071a21b3995448cd36a11cef"></a>kDiscrete&#160;</td><td class="fielddoc"><p >The dynamics are a function in the form xₖ₊₁ = f(t, xₖ, uₖ). </p>
</td></tr>
</table>

</div>
</div>
<a id="a63018833d7a0635f244a22539dfc76d1" name="a63018833d7a0635f244a22539dfc76d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63018833d7a0635f244a22539dfc76d1">&#9670;&nbsp;</a></span>ExpressionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacesleipnir.html#a63018833d7a0635f244a22539dfc76d1">sleipnir::ExpressionType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expression type. </p>
<p >Used for autodiff caching. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a63018833d7a0635f244a22539dfc76d1a35c3ace1970663a16e5c65baa5941b13" name="a63018833d7a0635f244a22539dfc76d1a35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"><p >There is no expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63018833d7a0635f244a22539dfc76d1a043b62a71551e8b511099802b2b59a98" name="a63018833d7a0635f244a22539dfc76d1a043b62a71551e8b511099802b2b59a98"></a>kConstant&#160;</td><td class="fielddoc"><p >The expression is a constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63018833d7a0635f244a22539dfc76d1aac97f0008bcf7c7fe4f2ff94160e1385" name="a63018833d7a0635f244a22539dfc76d1aac97f0008bcf7c7fe4f2ff94160e1385"></a>kLinear&#160;</td><td class="fielddoc"><p >The expression is composed of linear and lower-order operators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63018833d7a0635f244a22539dfc76d1af841876fc54bbdba16a4ae2e0d070714" name="a63018833d7a0635f244a22539dfc76d1af841876fc54bbdba16a4ae2e0d070714"></a>kQuadratic&#160;</td><td class="fielddoc"><p >The expression is composed of quadratic and lower-order operators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63018833d7a0635f244a22539dfc76d1aca517032c6fda1fd3881f922c50ed8d6" name="a63018833d7a0635f244a22539dfc76d1aca517032c6fda1fd3881f922c50ed8d6"></a>kNonlinear&#160;</td><td class="fielddoc"><p >The expression is composed of nonlinear and lower-order operators. </p>
</td></tr>
</table>

</div>
</div>
<a id="a79c3ac8825940144e76ed87f719b68d4" name="a79c3ac8825940144e76ed87f719b68d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c3ac8825940144e76ed87f719b68d4">&#9670;&nbsp;</a></span>SolverExitCondition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4">sleipnir::SolverExitCondition</a> : int8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solver exit condition. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a8c632159fa131f09d04f94e3cbcd8782" name="a79c3ac8825940144e76ed87f719b68d4a8c632159fa131f09d04f94e3cbcd8782"></a>kSuccess&#160;</td><td class="fielddoc"><p >Solved the problem to the desired tolerance. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a9545092cb61579e7f46a975d689b1bb8" name="a79c3ac8825940144e76ed87f719b68d4a9545092cb61579e7f46a975d689b1bb8"></a>kSolvedToAcceptableTolerance&#160;</td><td class="fielddoc"><p >Solved the problem to an acceptable tolerance, but not the desired one. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4ad4c976257a619492860b8840abbcaf42" name="a79c3ac8825940144e76ed87f719b68d4ad4c976257a619492860b8840abbcaf42"></a>kCallbackRequestedStop&#160;</td><td class="fielddoc"><p >The solver returned its solution so far after the user requested a stop. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4aa80022963c2851dfd91949197cac8966" name="a79c3ac8825940144e76ed87f719b68d4aa80022963c2851dfd91949197cac8966"></a>kTooFewDOFs&#160;</td><td class="fielddoc"><p >The solver determined the problem to be overconstrained and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a53ed66e6fa1f49615898ecce46fdbcb3" name="a79c3ac8825940144e76ed87f719b68d4a53ed66e6fa1f49615898ecce46fdbcb3"></a>kLocallyInfeasible&#160;</td><td class="fielddoc"><p >The solver determined the problem to be locally infeasible and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a23de0db053f48655155d173a39c62892" name="a79c3ac8825940144e76ed87f719b68d4a23de0db053f48655155d173a39c62892"></a>kFeasibilityRestorationFailed&#160;</td><td class="fielddoc"><p >The solver failed to reach the desired tolerance, and feasibility restoration failed to converge. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a08b5756e830054c09726f2d6ddfc98e4" name="a79c3ac8825940144e76ed87f719b68d4a08b5756e830054c09726f2d6ddfc98e4"></a>kNonfiniteInitialCostOrConstraints&#160;</td><td class="fielddoc"><p >The solver encountered nonfinite initial cost or constraints and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4abbefad5cbd24b04a4e4fb6bcae075c67" name="a79c3ac8825940144e76ed87f719b68d4abbefad5cbd24b04a4e4fb6bcae075c67"></a>kDivergingIterates&#160;</td><td class="fielddoc"><p >The solver encountered diverging primal iterates xₖ and/or sₖ and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4aad44d676f2d7acde9d736d83919b077f" name="a79c3ac8825940144e76ed87f719b68d4aad44d676f2d7acde9d736d83919b077f"></a>kMaxIterationsExceeded&#160;</td><td class="fielddoc"><p >The solver returned its solution so far after exceeding the maximum number of iterations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a7f27861ff1d3f550c6aa77150d7edabd" name="a79c3ac8825940144e76ed87f719b68d4a7f27861ff1d3f550c6aa77150d7edabd"></a>kTimeout&#160;</td><td class="fielddoc"><p >The solver returned its solution so far after exceeding the maximum elapsed wall clock time. </p>
</td></tr>
</table>

</div>
</div>
<a id="aa0c8390ba2ad034b958630d8b7d962b4" name="aa0c8390ba2ad034b958630d8b7d962b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c8390ba2ad034b958630d8b7d962b4">&#9670;&nbsp;</a></span>TimestepMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4">sleipnir::TimestepMethod</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum describing the type of system timestep. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa0c8390ba2ad034b958630d8b7d962b4a826888a09763de7e2a9f60eb85d88b24" name="aa0c8390ba2ad034b958630d8b7d962b4a826888a09763de7e2a9f60eb85d88b24"></a>kFixed&#160;</td><td class="fielddoc"><p >The timestep is a fixed constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0c8390ba2ad034b958630d8b7d962b4afb751f6ee1af15e773242f2accd2dbff" name="aa0c8390ba2ad034b958630d8b7d962b4afb751f6ee1af15e773242f2accd2dbff"></a>kVariable&#160;</td><td class="fielddoc"><p >The timesteps are allowed to vary as independent decision variables. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0c8390ba2ad034b958630d8b7d962b4a0b8eddab15f53a79424adf236397d84b" name="aa0c8390ba2ad034b958630d8b7d962b4a0b8eddab15f53a79424adf236397d84b"></a>kVariableSingle&#160;</td><td class="fielddoc"><p >The timesteps are equal length but allowed to vary as a single decision variable. </p>
</td></tr>
</table>

</div>
</div>
<a id="a7b6ff477fca07d31231aade7ce57207a" name="a7b6ff477fca07d31231aade7ce57207a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6ff477fca07d31231aade7ce57207a">&#9670;&nbsp;</a></span>TranscriptionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207a">sleipnir::TranscriptionMethod</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum describing an OCP transcription method. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7b6ff477fca07d31231aade7ce57207aae09070d9a1cb5eaf8c431ff130d77254" name="a7b6ff477fca07d31231aade7ce57207aae09070d9a1cb5eaf8c431ff130d77254"></a>kDirectTranscription&#160;</td><td class="fielddoc"><p >Each state is a decision variable constrained to the integrated dynamics of the previous state. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7b6ff477fca07d31231aade7ce57207aaeadf163719d8eaba16f306e4623348ae" name="a7b6ff477fca07d31231aade7ce57207aaeadf163719d8eaba16f306e4623348ae"></a>kDirectCollocation&#160;</td><td class="fielddoc"><p >The trajectory is modeled as a series of cubic polynomials where the centerpoint slope is constrained. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7b6ff477fca07d31231aade7ce57207aa6d0c9c617bab8979ca91133854abe778" name="a7b6ff477fca07d31231aade7ce57207aa6d0c9c617bab8979ca91133854abe778"></a>kSingleShooting&#160;</td><td class="fielddoc"><p >States depend explicitly as a function of all previous states and all previous inputs. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8bcb7ba159c1d2c57e30301122d332ce" name="a8bcb7ba159c1d2c57e30301122d332ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcb7ba159c1d2c57e30301122d332ce">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a8bcb7ba159c1d2c57e30301122d332ce" title="std::abs() for Variables.">std::abs()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad93830608ececa1b6655278a6c405de7" name="ad93830608ececa1b6655278a6c405de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93830608ececa1b6655278a6c405de7">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#ad93830608ececa1b6655278a6c405de7" title="std::acos() for Variables.">std::acos()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a080968b3ea028d444bc29448bfa29e97" name="a080968b3ea028d444bc29448bfa29e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080968b3ea028d444bc29448bfa29e97">&#9670;&nbsp;</a></span>AllocateIntrusiveShared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt; sleipnir::AllocateIntrusiveShared </td>
          <td>(</td>
          <td class="paramtype">Alloc&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type T and wraps it in an intrusive shared pointer using alloc as the storage allocator of T and args as the parameter list for the constructor of T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object for intrusive shared pointer. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of allocator for T. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of constructor arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The allocator for T. </td></tr>
    <tr><td class="paramname">args</td><td>Constructor arguments for T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33bb89eba6454138b7cd58a64054a7c8" name="a33bb89eba6454138b7cd58a64054a7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33bb89eba6454138b7cd58a64054a7c8">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a33bb89eba6454138b7cd58a64054a7c8" title="std::asin() for Variables.">std::asin()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0f210b7e74658edaf15731391a5cc30" name="aa0f210b7e74658edaf15731391a5cc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f210b7e74658edaf15731391a5cc30">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#aa0f210b7e74658edaf15731391a5cc30" title="std::atan() for Variables.">std::atan()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a630df7b189e4d16bff3726fe721d6152" name="a630df7b189e4d16bff3726fe721d6152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630df7b189e4d16bff3726fe721d6152">&#9670;&nbsp;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a630df7b189e4d16bff3726fe721d6152" title="std::atan2() for Variables.">std::atan2()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The y argument. </td></tr>
    <tr><td class="paramname">x</td><td>The x argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b87e3e8a405ae19e2f83758cd190d51" name="a4b87e3e8a405ae19e2f83758cd190d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b87e3e8a405ae19e2f83758cd190d51">&#9670;&nbsp;</a></span>Block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> sleipnir::Block </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assemble a <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks. </p>
<p >Each row's blocks must have the same height, and the assembled block rows must have the same width. For example, for the block matrix [[A, B], [C]] to be constructible, the number of rows in A and B must match, and the number of columns in [A, B] and [C] must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The nested list of blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad832e947d36c86a6e99381d1787137a6" name="ad832e947d36c86a6e99381d1787137a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad832e947d36c86a6e99381d1787137a6">&#9670;&nbsp;</a></span>Block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> sleipnir::Block </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assemble a <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks. </p>
<p >Each row's blocks must have the same height, and the assembled block rows must have the same width. For example, for the block matrix [[A, B], [C]] to be constructible, the number of rows in A and B must match, and the number of columns in [A, B] and [C] must match.</p>
<p >This overload is for Python bindings only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The nested list of blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1ae23d1e0093b86bc44621c4c49c0ea" name="aa1ae23d1e0093b86bc44621c4c49c0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ae23d1e0093b86bc44621c4c49c0ea">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#aa1ae23d1e0093b86bc44621c4c49c0ea" title="std::cos() for Variables.">std::cos()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a340047f0b6fb9d03a760f5804e2ddf07" name="a340047f0b6fb9d03a760f5804e2ddf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340047f0b6fb9d03a760f5804e2ddf07">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a340047f0b6fb9d03a760f5804e2ddf07" title="std::cosh() for Variables.">std::cosh()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0501d2b2d374051aada53be41ea076d7" name="a0501d2b2d374051aada53be41ea076d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0501d2b2d374051aada53be41ea076d7">&#9670;&nbsp;</a></span>CwiseReduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> sleipnir::CwiseReduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>(const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>binaryOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a coefficient-wise reduce operation to two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side of the binary operator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side of the binary operator. </td></tr>
    <tr><td class="paramname">binaryOp</td><td>The binary operator to use for the reduce operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a197c5c59bf157df1f414d7c2ccfe3b" name="a6a197c5c59bf157df1f414d7c2ccfe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a197c5c59bf157df1f414d7c2ccfe3b">&#9670;&nbsp;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a6a197c5c59bf157df1f414d7c2ccfe3b" title="std::erf() for Variables.">std::erf()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3f351c4c585bd5b7962a89f2e2a1155" name="ac3f351c4c585bd5b7962a89f2e2a1155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f351c4c585bd5b7962a89f2e2a1155">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::exp() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed489757f97c9302617cb499226741c2" name="aed489757f97c9302617cb499226741c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed489757f97c9302617cb499226741c2">&#9670;&nbsp;</a></span>function_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1function__ref.html">sleipnir::function_ref</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(Args...)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75c3a2b931fa1c5fccccd2740e9ef94d" name="a75c3a2b931fa1c5fccccd2740e9ef94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c3a2b931fa1c5fccccd2740e9ef94d">&#9670;&nbsp;</a></span>GlobalPoolAllocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1_pool_allocator.html">PoolAllocator</a>&lt; T &gt; sleipnir::GlobalPoolAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an allocator for a global pool memory resource. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of object in the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1e2d9ee285c6a874e470ddfe192bd50" name="ab1e2d9ee285c6a874e470ddfe192bd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e2d9ee285c6a874e470ddfe192bd50">&#9670;&nbsp;</a></span>GlobalPoolResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_pool_resource.html">PoolResource</a> &amp; sleipnir::GlobalPoolResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a global pool memory resource. </p>

</div>
</div>
<a id="a9f6e8e37214d28794471c8b01409a128" name="a9f6e8e37214d28794471c8b01409a128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6e8e37214d28794471c8b01409a128">&#9670;&nbsp;</a></span>hypot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::hypot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a75aa3a7748057d8c986042ad330758e4" title="std::hypot() for Variables.">std::hypot()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x argument. </td></tr>
    <tr><td class="paramname">y</td><td>The y argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75aa3a7748057d8c986042ad330758e4" name="a75aa3a7748057d8c986042ad330758e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aa3a7748057d8c986042ad330758e4">&#9670;&nbsp;</a></span>hypot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::hypot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a75aa3a7748057d8c986042ad330758e4" title="std::hypot() for Variables.">std::hypot()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x argument. </td></tr>
    <tr><td class="paramname">y</td><td>The y argument. </td></tr>
    <tr><td class="paramname">z</td><td>The z argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b7f81173d77cc67455e1c09391e32ff" name="a5b7f81173d77cc67455e1c09391e32ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7f81173d77cc67455e1c09391e32ff">&#9670;&nbsp;</a></span>InteriorPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void sleipnir::InteriorPoint </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt;&#160;</td>
          <td class="paramname"><em>decisionVariables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt;&#160;</td>
          <td class="paramname"><em>equalityConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt;&#160;</td>
          <td class="paramname"><em>inequalityConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; bool(const <a class="el" href="structsleipnir_1_1_solver_iteration_info.html">SolverIterationInfo</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsleipnir_1_1_solver_config.html">SolverConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>feasibilityRestoration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsleipnir_1_1_solver_status.html">SolverStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the optimal solution to a nonlinear program using the interior-point method. </p>
<p >A nonlinear program has the form:</p>
<pre class="fragment">     min_x f(x)
subject to cₑ(x) = 0
           cᵢ(x) ≥ 0
</pre><p >where f(x) is the cost function, cₑ(x) are the equality constraints, and cᵢ(x) are the inequality constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decisionVariables</td><td>The list of decision variables. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">equalityConstraints</td><td>The list of equality constraints. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inequalityConstraints</td><td>The list of inequality constraints. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The cost function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The user callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Configuration options for the solver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feasibilityRestoration</td><td>Whether to use feasibility restoration instead of the normal algorithm. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>The initial guess and output location for the decision variables. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>The initial guess and output location for the inequality constraint slack variables. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>The solver status. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c000918d7d254f363e71def1a77cce9" name="a9c000918d7d254f363e71def1a77cce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c000918d7d254f363e71def1a77cce9">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a9c000918d7d254f363e71def1a77cce9" title="std::log() for Variables.">std::log()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5f6511dbade8eb4e8486c5718015ddb" name="ad5f6511dbade8eb4e8486c5718015ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f6511dbade8eb4e8486c5718015ddb">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#ad5f6511dbade8eb4e8486c5718015ddb" title="std::log10() for Variables.">std::log10()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5505c6a23325ef4c196f9de5a694504" name="af5505c6a23325ef4c196f9de5a694504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5505c6a23325ef4c196f9de5a694504">&#9670;&nbsp;</a></span>MakeConstraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_small_vector.html">wpi::SmallVector</a>&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt; sleipnir::MakeConstraints </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a list of constraints. </p>
<p >The standard form for equality constraints is c(x) = 0, and the standard form for inequality constraints is c(x) ≥ 0. This function takes constraints of the form lhs = rhs or lhs ≥ rhs and converts them to lhs - rhs = 0 or lhs - rhs ≥ 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7912f1f51db075b3acf93320281326f7" name="a7912f1f51db075b3acf93320281326f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7912f1f51db075b3acf93320281326f7">&#9670;&nbsp;</a></span>MakeIntrusiveShared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt; sleipnir::MakeIntrusiveShared </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type T and wraps it in an intrusive shared pointer using args as the parameter list for the constructor of T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object for intrusive shared pointer. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of constructor arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments for T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68f27c3603b711f7ba34eac53651f907" name="a68f27c3603b711f7ba34eac53651f907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f27c3603b711f7ba34eac53651f907">&#9670;&nbsp;</a></span>Multistart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DecisionVariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt; sleipnir::Multistart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="structsleipnir_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt;(const DecisionVariables &amp;)&gt;&#160;</td>
          <td class="paramname"><em>solve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const DecisionVariables &gt;&#160;</td>
          <td class="paramname"><em>initialGuesses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves an optimization problem from different starting points in parallel, then returns the solution with the lowest cost. </p>
<p >Each solve is performed on a separate thread. Solutions from successful solves are always preferred over solutions from unsuccessful solves, and cost (lower is better) is the tiebreaker between successful solves.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DecisionVariables</td><td>The type containing the decision variable initial guess. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solve</td><td>A user-provided function that takes a decision variable initial guess and returns a <a class="el" href="structsleipnir_1_1_multistart_result.html" title="The result of a multistart solve.">MultistartResult</a>. </td></tr>
    <tr><td class="paramname">initialGuesses</td><td>A list of decision variable initial guesses to try. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add5f8232b7a7dfbd13239455ef47da5b" name="add5f8232b7a7dfbd13239455ef47da5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5f8232b7a7dfbd13239455ef47da5b">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a> sleipnir::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Less-than comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22d6a0d536d82302d3e3c29786e53219" name="a22d6a0d536d82302d3e3c29786e53219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d6a0d536d82302d3e3c29786e53219">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a> sleipnir::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Less-than-or-equal-to comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58cac593a1dd030744b85cbe3d0e7da6" name="a58cac593a1dd030744b85cbe3d0e7da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cac593a1dd030744b85cbe3d0e7da6">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_equality_constraints.html">EqualityConstraints</a> sleipnir::operator== </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator that returns an equality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2eb85f8960aa6b9efc40aabb9b1a2fa" name="ab2eb85f8960aa6b9efc40aabb9b1a2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2eb85f8960aa6b9efc40aabb9b1a2fa">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a> sleipnir::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greater-than comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ababe98061e7c0f7d6e1334457af169ac" name="ababe98061e7c0f7d6e1334457af169ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababe98061e7c0f7d6e1334457af169ac">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a> sleipnir::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greater-than-or-equal-to comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f18573caf44bef6642332ad98ff4f9a" name="a9f18573caf44bef6642332ad98ff4f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f18573caf44bef6642332ad98ff4f9a">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a9f18573caf44bef6642332ad98ff4f9a" title="std::pow() for Variables.">std::pow()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base. </td></tr>
    <tr><td class="paramname">power</td><td>The power. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9442c1a3c76b61a27bfc46bed4a0cc5b" name="a9442c1a3c76b61a27bfc46bed4a0cc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9442c1a3c76b61a27bfc46bed4a0cc5b">&#9670;&nbsp;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a56a828fb91283babdb0eef8e0d9010cb">fmt::format_string</a>&lt; T... &gt;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around <a class="el" href="namespacesleipnir.html#a70d0e712de46cfa1e7a9456b0519257e" title="Wrapper around fmt::print() that squelches write failure exceptions.">fmt::print()</a> that squelches write failure exceptions. </p>

</div>
</div>
<a id="a70d0e712de46cfa1e7a9456b0519257e" name="a70d0e712de46cfa1e7a9456b0519257e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d0e712de46cfa1e7a9456b0519257e">&#9670;&nbsp;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::print </td>
          <td>(</td>
          <td class="paramtype">std::FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a56a828fb91283babdb0eef8e0d9010cb">fmt::format_string</a>&lt; T... &gt;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around <a class="el" href="namespacesleipnir.html#a70d0e712de46cfa1e7a9456b0519257e" title="Wrapper around fmt::print() that squelches write failure exceptions.">fmt::print()</a> that squelches write failure exceptions. </p>

</div>
</div>
<a id="a0758fba396daf7bac66206f04df32b31" name="a0758fba396daf7bac66206f04df32b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0758fba396daf7bac66206f04df32b31">&#9670;&nbsp;</a></span>println() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::println </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a56a828fb91283babdb0eef8e0d9010cb">fmt::format_string</a>&lt; T... &gt;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around <a class="el" href="namespacesleipnir.html#a225e73b7f33254984c4bd99107c5e564" title="Wrapper around fmt::println() that squelches write failure exceptions.">fmt::println()</a> that squelches write failure exceptions. </p>

</div>
</div>
<a id="a225e73b7f33254984c4bd99107c5e564" name="a225e73b7f33254984c4bd99107c5e564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225e73b7f33254984c4bd99107c5e564">&#9670;&nbsp;</a></span>println() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::println </td>
          <td>(</td>
          <td class="paramtype">std::FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a56a828fb91283babdb0eef8e0d9010cb">fmt::format_string</a>&lt; T... &gt;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around <a class="el" href="namespacesleipnir.html#a225e73b7f33254984c4bd99107c5e564" title="Wrapper around fmt::println() that squelches write failure exceptions.">fmt::println()</a> that squelches write failure exceptions. </p>

</div>
</div>
<a id="ac3e055561e1b55a4f4efdfc1dcb06ff8" name="ac3e055561e1b55a4f4efdfc1dcb06ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e055561e1b55a4f4efdfc1dcb06ff8">&#9670;&nbsp;</a></span>RK4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename State , typename Input , typename Time &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">State sleipnir::RK4 </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">State&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Time&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Time&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs 4th order Runge-Kutta integration of dx/dt = f(t, x, u) for dt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate. It must take two arguments x and u. </td></tr>
    <tr><td class="paramname">x</td><td>The initial value of x. </td></tr>
    <tr><td class="paramname">u</td><td>The value u held constant over the integration period. </td></tr>
    <tr><td class="paramname">t0</td><td>The initial time. </td></tr>
    <tr><td class="paramname">dt</td><td>The time over which to integrate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36ee3b7626080eaba8e8b65467bf23b2" name="a36ee3b7626080eaba8e8b65467bf23b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ee3b7626080eaba8e8b65467bf23b2">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::sign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a36ee3b7626080eaba8e8b65467bf23b2" title="sign() for Variables.">sign()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a2f17480dc7667bca2b8f027a9ff1f1" name="a1a2f17480dc7667bca2b8f027a9ff1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2f17480dc7667bca2b8f027a9ff1f1">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a1a2f17480dc7667bca2b8f027a9ff1f1" title="std::sin() for Variables.">std::sin()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fdce37409d87f0aa0d5c124ff555a58" name="a7fdce37409d87f0aa0d5c124ff555a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdce37409d87f0aa0d5c124ff555a58">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a7fdce37409d87f0aa0d5c124ff555a58" title="std::sinh() for Variables.">std::sinh()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a069c0c391e426f231f1ed5e28288fbe9" name="a069c0c391e426f231f1ed5e28288fbe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069c0c391e426f231f1ed5e28288fbe9">&#9670;&nbsp;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> sleipnir::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> equation AX = B for X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The left-hand side. </td></tr>
    <tr><td class="paramname">B</td><td>The right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The solution X. </dd></dl>

</div>
</div>
<a id="a7317a14ecb6fd2609fc40a0ea2577cc1" name="a7317a14ecb6fd2609fc40a0ea2577cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7317a14ecb6fd2609fc40a0ea2577cc1">&#9670;&nbsp;</a></span>Spy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void sleipnir::Spy </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the sparsity pattern of a sparse matrix to a file. </p>
<p >Each character represents an element with '.' representing zero, '+' representing positive, and '-' representing negative. Here's an example for a 3x3 identity matrix.</p>
<p >"+.." ".+." "..+"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">file</td><td>A file stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>The sparse matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89c613f4826d87e80d9ee015cc56a5ff" name="a89c613f4826d87e80d9ee015cc56a5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c613f4826d87e80d9ee015cc56a5ff">&#9670;&nbsp;</a></span>Spy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void sleipnir::Spy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the sparsity pattern of a sparse matrix to a file. </p>
<p >Each character represents an element with "." representing zero, "+" representing positive, and "-" representing negative. Here's an example for a 3x3 identity matrix.</p>
<p >"+.." ".+." "..+"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The filename. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>The sparse matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab400367eb603c4220c814bde2ef91c5f" name="ab400367eb603c4220c814bde2ef91c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab400367eb603c4220c814bde2ef91c5f">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#ab400367eb603c4220c814bde2ef91c5f" title="std::sqrt() for Variables.">std::sqrt()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b18604d3561d5bacf5281f1e6cf1993" name="a7b18604d3561d5bacf5281f1e6cf1993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b18604d3561d5bacf5281f1e6cf1993">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void sleipnir::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the referred callables of <code>lhs</code> and <code>rhs</code>. </p>

</div>
</div>
<a id="ab2190666baa579f39848387efb37a228" name="ab2190666baa579f39848387efb37a228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2190666baa579f39848387efb37a228">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::tan() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a241833c33e81b406cfbfc069342c339a" name="a241833c33e81b406cfbfc069342c339a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241833c33e81b406cfbfc069342c339a">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacesleipnir.html#a241833c33e81b406cfbfc069342c339a" title="std::tanh() for Variables.">std::tanh()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55a4065c9b3ad44d3d1a77f6fa9600ee" name="a55a4065c9b3ad44d3d1a77f6fa9600ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a4065c9b3ad44d3d1a77f6fa9600ee">&#9670;&nbsp;</a></span>ToMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> sleipnir::ToMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesleipnir.html#a79c3ac8825940144e76ed87f719b68d4">SolverExitCondition</a> &amp;&#160;</td>
          <td class="paramname"><em>exitCondition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns user-readable message corresponding to the exit condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exitCondition</td><td>Solver exit condition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a703d7cfeaa4b7bfabb6c20675a7e9055" name="a703d7cfeaa4b7bfabb6c20675a7e9055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703d7cfeaa4b7bfabb6c20675a7e9055">&#9670;&nbsp;</a></span>Hessian</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_hessian.html">sleipnir::Hessian</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad566a82c0d33a39db1e2398075083bd8" name="ad566a82c0d33a39db1e2398075083bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad566a82c0d33a39db1e2398075083bd8">&#9670;&nbsp;</a></span>Jacobian</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_jacobian.html">sleipnir::Jacobian</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesleipnir.html">sleipnir</a></li>
    <li class="footer">Generated on Fri Jun 28 2024 05:29:48 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
